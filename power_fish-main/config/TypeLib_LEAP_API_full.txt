// Generated .IDL file (by the OLE/COM Object Viewer)
// 
// typelib filename: leap.exe

[
  uuid(6161465F-91BE-4B6B-8BB0-361F5BFA612A),
  version(2.3),
  helpstring("LEAP API")
]
library Leap
{
    // TLib : OLE Automation : {00020430-0000-0000-C000-000000000046}
    importlib("stdole2.tlb");

    // Forward declare all types defined in this typelib
    interface ILEAPApplication;
    interface ILEAPScenario;
    interface ILEAPScenarios;
    interface ILEAPBranches;
    interface ILEAPBranch;
    interface ILEAPVariables;
    interface ILEAPAreas;
    interface ILEAPArea;
    dispinterface ILEAPApplicationEvents;
    interface ILEAPVariable;
    interface ILEAPRegion;
    interface ILEAPRegions;
    interface ILEAPFuel;
    interface ILEAPFuels;
    interface ILEAPFavorite;
    interface ILEAPFavorites;
    interface ILEAPUnit;
    interface ILEAPUnits;
    interface ILEAPVersion;
    interface ILEAPVersions;
    interface ILEAPView;
    interface ILEAPViews;
    interface ILEAPUserVariable;
    interface ILEAPUserVariables;
    interface ILEAPEffects;
    interface ILEAPEffect;
    interface ITEDTechnologies;
    interface ITEDTechnology;
    interface ILEAPDimension;
    interface ILEAPDimensions;
    interface ILEAPTimeSlice;
    interface ILEAPTimeSlices;
    interface ILEAPYearlyShape;
    interface ILEAPYearlyShapes;
    interface IAutoWEAPLinkage;
    interface ILEAPTags;
    interface ILEAPTag;
    interface ILEAPTagGroups;
    interface ILEAPTagGroup;
    interface ILEAPFuelGroup;
    interface ILEAPFuelGroups;
    interface ILEAPRegionGroup;
    interface ILEAPRegionGroups;
    interface ILEAPCountries;
    interface ILEAPCountry;
    interface ILEAPLandTypes;
    interface ILEAPLandType;
    interface ILEAPConstants;
    interface ILEAPConstant;

    [
      odl,
      uuid(89B28255-09DD-47D1-AC84-B01694664FA9),
      version(1.0),
      helpstring("Dispatch interface for LEAPApplication Object"),
      dual,
      oleautomation
    ]
    interface ILEAPApplication : IDispatch {
        [id(0x000000c9), helpstring("Show the chart in Results view.")]
        HRESULT ShowResultsViewChart();
        [id(0x000000ca), hidden, helpstring("Obsolete.  Use LEAP.Views("Analysis")")]
        HRESULT ShowAnalysisView();
        [id(0x000000cb), hidden, helpstring("Obsolete.  Use LEAP.Views("Energy Balance")")]
        HRESULT ShowEnergyBalanceView();
        [id(0x000000cc), helpstring("Saves the current area.")]
        HRESULT SaveArea();
        [id(0x000000ce), helpstring("Show the table in Results view.")]
        HRESULT ShowResultsViewTable();
        [id(0x000000d0), propget, helpstring("For development only. Do not use.")]
        HRESULT Status([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d1), hidden, helpstring("Obsolete.  Use LEAP.Views("Notes")")]
        HRESULT ShowNotesView();
        [id(0x000000d2), hidden, helpstring("Obsolete.  Use LEAP.Views("Overview")")]
        HRESULT ShowOverview();
        [id(0x000000d3), hidden, helpstring("Obsolete.  Use LEAP.Views("Diagram")")]
        HRESULT ShowDiagramView();
        [id(0x000000d4), helpstring("Exports the current results view chart to Microsoft PowerPoint.  If the title and subtitle are left blank, LEAP will use the default auto-generated titles and subtitles.")]
        HRESULT ExportResultsPPT(
                        [in, optional, defaultvalue("")] BSTR TitleCap, 
                        [in, optional, defaultvalue("")] BSTR SubTitleCap);
        [id(0x000000d5), helpstring("Exports the current results view table to Microsoft Excel.  If specified, TabTitle will be used to label the sheet tab in the Excel workbook.")]
        HRESULT ExportResultsXLS([in, optional, defaultvalue("")] BSTR XLTabTitle);
        [id(0x000000d6), helpstring("Copies the current Results View chart to the clipboard.  If the title and subtitle are left blank, LEAP will use the default auto-generated titles and subtitles.")]
        HRESULT CopyResultsChart(
                        [in, optional, defaultvalue("")] BSTR TitleCap, 
                        [in, optional, defaultvalue("")] BSTR SubTitleCap);
        [id(0x000000d7), helpstring("Copies the current Results View table to the clipboard.")]
        HRESULT CopyResultsTable();
        [id(0x000000da), helpstring("Brings the LEAP application window to the front in the stack of windows on your desktop.")]
        HRESULT BringToFront();
        [id(0x000000db), helpstring("Minimizes the LEAP Application window to the Windows task bar.")]
        HRESULT Minimize();
        [id(0x000000dd), helpstring("Restores the LEAP Application window if it was minimized to the Windows task bar.")]
        HRESULT Restore();
        [id(0x000000de), helpstring("Imports expressions from Excel.")]
        HRESULT ImportExpressions();
        [id(0x000000df), helpstring("Exports all expressions from LEAP to Excel.")]
        HRESULT ExportExpressions();
        [id(0x000000e0), helpstring("Exports data values from LEAP to Excel.")]
        HRESULT ExportData();
        [id(0x000000d8), propget, helpstring("Gets or sets whether the LEAP application is visible.")]
        HRESULT Visible([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d8), propput, helpstring("Gets or sets whether the LEAP application is visible.")]
        HRESULT Visible([in] VARIANT_BOOL Value);
        [id(0x000000e5), propget, helpstring("Gets or sets a variable that controls what types of messages will be displayed on screen while LEAP is being automated.  The possible settings are: 0=nothing (silent operation), 1=Only show errors, 2=Show errors and questions, 3=Show errors, questions and warnings, 4=Show all messages.  When LEAP is NOT being automated, Verbose equals 4.")]
        HRESULT Verbose([out, retval] long* Value);
        [id(0x000000e5), propput, helpstring("Gets or sets a variable that controls what types of messages will be displayed on screen while LEAP is being automated.  The possible settings are: 0=nothing (silent operation), 1=Only show errors, 2=Show errors and questions, 3=Show errors, questions and warnings, 4=Show all messages.  When LEAP is NOT being automated, Verbose equals 4.")]
        HRESULT Verbose([in] long Value);
        [id(0x000000e6), propget, helpstring("Gets or sets the visibility of the splash screen.")]
        HRESULT ShowSplash([out, retval] VARIANT_BOOL* Value);
        [id(0x000000e6), propput, helpstring("Gets or sets the visibility of the splash screen.")]
        HRESULT ShowSplash([in] VARIANT_BOOL Value);
        [id(0x000000e7), propget, helpstring("Gets or sets the base year: the first year of the study period.")]
        HRESULT BaseYear([out, retval] long* Value);
        [id(0x000000e7), propput, helpstring("Gets or sets the base year: the first year of the study period.")]
        HRESULT BaseYear([in] long Value);
        [id(0x000000e8), propget, helpstring("Gets or sets the end year: the last year of the study period.")]
        HRESULT EndYear([out, retval] long* Value);
        [id(0x000000e8), propput, helpstring("Gets or sets the end year: the last year of the study period.")]
        HRESULT EndYear([in] long Value);
        [id(0x000000e9), propget, helpstring("Gets a text string representing the current version of LEAP (e.g. 2015.XXX).")]
        HRESULT SoftwareVersion([out, retval] BSTR* Value);
        [id(0x000000ea), propget, helpstring("Gets the version of the LEAP data dictionary.")]
        HRESULT DictionaryVersion([out, retval] long* Value);
        [id(0x000000e2), propget, helpstring("Get a LEAP scenario object from its name.")]
        HRESULT Scenario(
                        [in] VARIANT ScenarioName, 
                        [out, retval] ILEAPScenario** Value);
        [id(0x000000eb), propget, helpstring("Gets the collection of all LEAP scenarios.")]
        HRESULT Scenarios([out, retval] ILEAPScenarios** Value);
        [id(0x000000ec), propget, helpstring("Obsolete. Use LEAP.Branches("BranchPath")")]
        HRESULT Branch(
                        [in, defaultvalue("")] BSTR BranchName, 
                        [out, retval] ILEAPBranch** Value);
        [id(0x000000ee), propget, helpstring("Gets a LEAPVariable object for the specified branch and variable. BranchName is written in standard path notation using the \ character to separate levels in the tree: a colon is used to separate BranchName and VariableName.  VariableName can be omitted if BranchName only has one variable. Note: This is equivalent to Branch(BranchName).Variables(VariableName). Returns a LEAPVariable object.")]
        HRESULT BranchVariable(
                        [in] BSTR BranchVariableName, 
                        [out, retval] ILEAPVariable** Value);
        [id(0x000000ef), propget, helpstring("Gets or sets the active area. Returns a LEAPArea object.  Can be set equal to an area name an index or a LEAPArea object.")]
        HRESULT ActiveArea([out, retval] VARIANT* Value);
        [id(0x000000ef), propput, helpstring("Gets or sets the active area. Returns a LEAPArea object.  Can be set equal to an area name an index or a LEAPArea object.")]
        HRESULT ActiveArea([in] VARIANT Value);
        [id(0x000000f0), propget, helpstring("Sets or gets the active scenario.  Returns a LEAPScenario object.   Can be set equal to a scenario name, index or a LEAPScenario object.  In analysis view, setting ActiveScenario changes the currently selected scenario.  In the Results or Energy Balance views setting ActiveScenario displays results for the ActiveScenario. In ResultsView you can only get or set the ActiveScenario if scenarios are not on the legend or X axis dimension of a chart.")]
        HRESULT ActiveScenario([out, retval] VARIANT* Value);
        [id(0x000000f0), propput, helpstring("Sets or gets the active scenario.  Returns a LEAPScenario object.   Can be set equal to a scenario name, index or a LEAPScenario object.  In analysis view, setting ActiveScenario changes the currently selected scenario.  In the Results or Energy Balance views setting ActiveScenario displays results for the ActiveScenario. In ResultsView you can only get or set the ActiveScenario if scenarios are not on the legend or X axis dimension of a chart.")]
        HRESULT ActiveScenario([in] VARIANT Value);
        [id(0x000000f1), helpstring("Saves a new backup version of the current area.")]
        HRESULT SaveVersion(
                        [in, optional, defaultvalue("")] BSTR Comment, 
                        [in, optional, defaultvalue(-1)] VARIANT_BOOL IncludeResults);
        [id(0x000000f2), propget, helpstring("Gets the full path of the folder in which LEAP is installed.")]
        HRESULT ProgramDirectory([out, retval] BSTR* Value);
        [id(0x000000f4), propget, helpstring("Gets a string with system information on your PC.")]
        HRESULT ComputerInfo([out, retval] BSTR* Value);
        [id(0x000000f5), propget, helpstring("The name of the software running (LEAP)")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(0x000000f6), propget, helpstring("Returns the collection of all visible branches in the tree. Returns a LEAPBranches object.")]
        HRESULT Branches([out, retval] ILEAPBranches** Value);
        [id(0x000000f7), propget, helpstring("Returns true if LEAP is properly started (i.e reached the Analysis view screen.)")]
        HRESULT ProgramStarted([out, retval] VARIANT_BOOL* Value);
        [id(0x000000f8), propget, helpstring("Gets or sets the first scenario year of the study.  Scenario expressions are used to generate data values only on and after the first scenario year.  Before this year, Current Accounts expressions are used, regardless of the information in the scenario expression.")]
        HRESULT FirstScenarioYear([out, retval] long* Value);
        [id(0x000000f8), propput, helpstring("Gets or sets the first scenario year of the study.  Scenario expressions are used to generate data values only on and after the first scenario year.  Before this year, Current Accounts expressions are used, regardless of the information in the scenario expression.")]
        HRESULT FirstScenarioYear([in] long Value);
        [id(0x000000e3), propget, helpstring("Get a LEAP region object from its name.")]
        HRESULT Region(
                        [in] VARIANT RegionName, 
                        [out, retval] ILEAPRegion** Value);
        [id(0x000000fb), propget, helpstring("Gets the collection of all LEAP regions.")]
        HRESULT Regions([out, retval] ILEAPRegions** Value);
        [id(0x000000f9), propget, helpstring("Get a LEAP fuel object from its name.")]
        HRESULT Fuel(
                        [in] VARIANT FuelName, 
                        [out, retval] ILEAPFuel** Value);
        [id(0x000000fa), propget, helpstring("Gets the collection of all LEAP fuels. ")]
        HRESULT Fuels([out, retval] ILEAPFuels** Value);
        [id(0x000000fc), propget, helpstring("Gets the collection of all Favorites (saved charts).")]
        HRESULT Favorites([out, retval] ILEAPFavorites** Value);
        [id(0x000000fd), propget, helpstring("Obsolete. Please Use LEAP.Favorite("Name") instead.")]
        HRESULT Favorite(
                        [in] BSTR FavoriteName, 
                        [out, retval] ILEAPFavorite** Value);
        [id(0x000000cf), propget, helpstring("Gets the collection of all units.")]
        HRESULT Units([out, retval] ILEAPUnits** Value);
        [id(0x000000fe), propget, helpstring("Deprecated. Please use LEAP.Units("Name) instead.")]
        HRESULT Unit(
                        [in] VARIANT UnitName, 
                        [out, retval] ILEAPUnit** Value);
        [id(0x000000ff), propget, helpstring("Gets or set the global area discount rate (%).")]
        HRESULT DiscountRate([out, retval] double* Value);
        [id(0x000000ff), propput, helpstring("Gets or set the global area discount rate (%).")]
        HRESULT DiscountRate([in] double Value);
        [id(0x000000e4), propget, helpstring("Get a LEAP area object from its name.")]
        HRESULT Area(
                        [in] BSTR AreaName, 
                        [out, retval] ILEAPArea** Value);
        [id(0x000000ed), propget, helpstring("Gets the collection of all LEAP areas.  Returns a LEAPAreas collection.")]
        HRESULT Areas([out, retval] ILEAPAreas** Value);
        [id(0x00000100), propget, helpstring("Gets the full path of the LEAP working directory.")]
        HRESULT WorkingDirectory([out, retval] BSTR* Value);
        [id(0x00000101), propget, helpstring("Gets the current registered user name.")]
        HRESULT UserName([out, retval] BSTR* Value);
        [id(0x00000102), propget, helpstring("Returns TRUE if LEAP's optional mapping components are installed.  FALSE if not.")]
        HRESULT MappingInstalled([out, retval] VARIANT_BOOL* Value);
        [id(0x000000dc), propget, helpstring("Gets the collection of all LEAP versions for the current area.  Versions are backups of a LEAP area.  Returns a LEAPVersions collection.")]
        HRESULT Versions([out, retval] ILEAPVersions** Value);
        [id(0x000000d9), helpstring("Forces LEAP to calculate the next time results are requested, regardless of whether data has been changed.")]
        HRESULT ForceCalculation();
        [id(0x00000103), propget, helpstring("Gets or sets the active region, returning a LEAPRegion object.  Can be set equal to a region name, index or a LEAPRegion object.  In the analysis view setting ActiveRegion changes the currently selected region. In the Results or EnergyBalance views setting ActiveRegion displays results for the ActiveRegion. In ResultsView you can only get or set the ActiveRegion if regions are not on the legend or X axis dimension of a chart.  Many data sets have only one region, in which case regions are hidden from view in LEAP.")]
        HRESULT ActiveRegion([out, retval] VARIANT* Value);
        [id(0x00000103), propput, helpstring("Gets or sets the active region, returning a LEAPRegion object.  Can be set equal to a region name, index or a LEAPRegion object.  In the analysis view setting ActiveRegion changes the currently selected region. In the Results or EnergyBalance views setting ActiveRegion displays results for the ActiveRegion. In ResultsView you can only get or set the ActiveRegion if regions are not on the legend or X axis dimension of a chart.  Many data sets have only one region, in which case regions are hidden from view in LEAP.")]
        HRESULT ActiveRegion([in] VARIANT Value);
        [id(0x00000104), propget, helpstring("Gets or sets the active branch in the tree.  Returns a LEAPBranch branch object. Can be set equal to a branch name (full branch path) or a LEAPBranch object.")]
        HRESULT ActiveBranch([out, retval] VARIANT* Value);
        [id(0x00000104), propput, helpstring("Gets or sets the active branch in the tree.  Returns a LEAPBranch branch object. Can be set equal to a branch name (full branch path) or a LEAPBranch object.")]
        HRESULT ActiveBranch([in] VARIANT Value);
        [id(0x000000f3), propget, helpstring("Returns a result value for the specified branch and variable for a particular year. Results are returned in the unit specified by unit name.")]
        HRESULT ResultValue(
                        [in, defaultvalue("")] BSTR BranchVarName, 
                        [in, defaultvalue(0)] int Year, 
                        [in, defaultvalue("")] BSTR UnitName, 
                        [out, retval] double* Value);
        [id(0x00000105), propget, helpstring("Gets or sets the active variable.  Returns a LEAPVariable object.   Can be set equal to a variable name or a LEAPVariable object.")]
        HRESULT ActiveVariable([out, retval] VARIANT* Value);
        [id(0x00000105), propput, helpstring("Gets or sets the active variable.  Returns a LEAPVariable object.   Can be set equal to a variable name or a LEAPVariable object.")]
        HRESULT ActiveVariable([in] VARIANT Value);
        [id(0x000000e1), propget, helpstring("Sets or gets the active view.  Returns a LEAPView object.   Can be set equal to a view name or a LEAPView object.")]
        HRESULT ActiveView([out, retval] VARIANT* Value);
        [id(0x000000e1), propput, helpstring("Sets or gets the active view.  Returns a LEAPView object.   Can be set equal to a view name or a LEAPView object.")]
        HRESULT ActiveView([in] VARIANT Value);
        [id(0x00000106), helpstring("Prints a number or a text string.  Print statements are sent to the APIPrint.txt file.  This file is automatically monitored and displayed in LEAP's Script Editor.")]
        HRESULT Print([in, optional] VARIANT Value);
        [id(0x00000107), hidden, helpstring("Prints a number or a text string.  Print statements are sent to the APIPrint.txt file.  This file is automatically monitored and displayed in LEAP's Script Editor.")]
        HRESULT P([in, optional] VARIANT Value);
        [id(0x00000108), helpstring("Clears the PRINT outputs. Only used in LEAP's built-in script editor tool.")]
        HRESULT Clear();
        [id(0x00000109), helpstring("Clears the PRINT outputs. Only used in LEAP's built-in script editor tool.")]
        HRESULT CLS();
        [id(0x0000010a), helpstring("Shuts down LEAP. Call CanQuit first. Equivalent to setting the LEAPApplication object equal to nil.")]
        HRESULT Quit();
        [id(0x0000010b), propget, helpstring("Gets the collection of all LEAP views. Returns a LEAPViews collection.")]
        HRESULT Views([out, retval] ILEAPViews** Value);
        [id(0x0000010c), propget, hidden, helpstring("Deprecated. Please use LEAP.Views("Name") instead.")]
        HRESULT View(
                        [in] VARIANT ViewName, 
                        [out, retval] ILEAPView** Value);
        [id(0x0000010d), helpstring("Starts a LEAP calculation and after success switches to the Results View.")]
        HRESULT Calculate([in, defaultvalue(-1)] VARIANT_BOOL CalculateWEAP);
        [id(0x0000010e), propget, helpstring("Gets or sets the filename for the script that occurs before calculation (if any).")]
        HRESULT BeforeCalc([out, retval] BSTR* Value);
        [id(0x0000010e), propput, helpstring("Gets or sets the filename for the script that occurs before calculation (if any).")]
        HRESULT BeforeCalc([in] BSTR Value);
        [id(0x0000010f), propget, hidden, helpstring("Gets or sets the filename for the script that occurs before each region is calculated (if any).")]
        HRESULT BeforeRegionCalc([out, retval] BSTR* Value);
        [id(0x0000010f), propput, hidden, helpstring("Gets or sets the filename for the script that occurs before each region is calculated (if any).")]
        HRESULT BeforeRegionCalc([in] BSTR Value);
        [id(0x00000110), propget, helpstring("Gets or sets the filename for the script that occurs before each scenario is calculated (if any).")]
        HRESULT BeforeScenarioCalc([out, retval] BSTR* Value);
        [id(0x00000110), propput, helpstring("Gets or sets the filename for the script that occurs before each scenario is calculated (if any).")]
        HRESULT BeforeScenarioCalc([in] BSTR Value);
        [id(0x00000111), propget, hidden, helpstring("Gets or sets the filename for the script that occurs before non energy branches are calculated (if any).")]
        HRESULT BeforeNonEnergyCalc([out, retval] BSTR* Value);
        [id(0x00000111), propput, hidden, helpstring("Gets or sets the filename for the script that occurs before non energy branches are calculated (if any).")]
        HRESULT BeforeNonEnergyCalc([in] BSTR Value);
        [id(0x00000112), propget, hidden, helpstring("Gets or sets the filename for the script that occurs before demands are calculated (if any).")]
        HRESULT BeforeDemandCalc([out, retval] BSTR* Value);
        [id(0x00000112), propput, hidden, helpstring("Gets or sets the filename for the script that occurs before demands are calculated (if any).")]
        HRESULT BeforeDemandCalc([in] BSTR Value);
        [id(0x00000113), propget, helpstring("Gets or sets the filename for the script that occurs before Transformation is calculated (if any).")]
        HRESULT BeforeTransformationCalc([out, retval] BSTR* Value);
        [id(0x00000113), propput, helpstring("Gets or sets the filename for the script that occurs before Transformation is calculated (if any).")]
        HRESULT BeforeTransformationCalc([in] BSTR Value);
        [id(0x00000114), propget, hidden, helpstring("Gets or sets the filename for the script that occurs before resources are calculated (if any).")]
        HRESULT BeforeResourceCalc([out, retval] BSTR* Value);
        [id(0x00000114), propput, hidden, helpstring("Gets or sets the filename for the script that occurs before resources are calculated (if any).")]
        HRESULT BeforeResourceCalc([in] BSTR Value);
        [id(0x00000116), propget, helpstring("Gets or sets the filename for the script that occurs after all calculations (if any).")]
        HRESULT AfterCalc([out, retval] BSTR* Value);
        [id(0x00000116), propput, helpstring("Gets or sets the filename for the script that occurs after all calculations (if any).")]
        HRESULT AfterCalc([in] BSTR Value);
        [id(0x00000117), propget, helpstring("Returns true if LEAP is being calculated (i.e. not available to accept inputs).")]
        HRESULT IsCalculating([out, retval] VARIANT_BOOL* Value);
        [id(0x00000118), propget, helpstring("The file name of the currently active script.")]
        HRESULT ActiveScript([out, retval] BSTR* Value);
        [id(0x00000119), helpstring("Prints a number or a text string to a named text file.  ")]
        HRESULT PrintToFile(
                        [in] VARIANT Value, 
                        [in] BSTR FileName);
        [id(0x0000011a), propget, helpstring("Gets or sets whether additional calculations are used to allocate secondary energy consumption back to energy demand branches.")]
        HRESULT CalcPrimaryEnergy([out, retval] VARIANT_BOOL* Value);
        [id(0x0000011a), propput, helpstring("Gets or sets whether additional calculations are used to allocate secondary energy consumption back to energy demand branches.")]
        HRESULT CalcPrimaryEnergy([in] VARIANT_BOOL Value);
        [id(0x0000011b), propget, helpstring("Gets or sets whether Transformation branches are visible and Transformation calculations are included.")]
        HRESULT ShowTransformation([out, retval] VARIANT_BOOL* Value);
        [id(0x0000011b), propput, helpstring("Gets or sets whether Transformation branches are visible and Transformation calculations are included.")]
        HRESULT ShowTransformation([in] VARIANT_BOOL Value);
        [id(0x0000011c), helpstring("Exports the current results view table to the named text file in comma separated value format (CSV).")]
        HRESULT ExportResultsCSV([in] BSTR FileName);
        [id(0x0000011e), propget, helpstring("Adds a new demand category branch to the tree with name Bname.  Adds the branch as a child to the existing branch with branch ID ParentID.  The Scale and ActivityUnit parameters are text parameters that indicate the scaling factor and activity unit for the activity level variable of the new branch.")]
        HRESULT AddCategory(
                        [in] int ParentID, 
                        [in] BSTR BName, 
                        [in] VARIANT Scale, 
                        [in] VARIANT AcUnit, 
                        [out, retval] ILEAPBranch** Value);
        [id(0x0000011f), propget, helpstring("Adds a new demand technology branch (using the Activity Analysis method) to the tree with name BName.  Adds the branch as a child to the existing branch with branch ID ParentID.  The Scale and ActivityUnit parameters are text parameters that indicate the scaling factor and activity unit for the activity level variable of the new branch.  The Fuel parameter is a text parameter indicating the fuel associated with the branch.  The EnergyUnit parameter is another text parameter indicating the unit of measurement of the energy intensity variable.  ParentID is an integer parameter, which must refer to a demand category branch.")]
        HRESULT AddTechnology(
                        [in] int ParentID, 
                        [in] BSTR BName, 
                        [in] VARIANT Scale, 
                        [in] VARIANT AcUnit, 
                        [in] VARIANT Fuel, 
                        [in] VARIANT EnergyUnit, 
                        [out, retval] ILEAPBranch** Value);
        [id(0x0000011d), propget, helpstring("Adds a new Transformation process with name BName under a branch with ID ParentID.  Fuel is a text parameter indicating the first feedstock fuel of the process.  ParentID is an integer parameter, which must refer to a process category branch.")]
        HRESULT AddProcess(
                        [in] int ParentID, 
                        [in] BSTR BName, 
                        [in] VARIANT Fuel, 
                        [in] int DispatchRule, 
                        [out, retval] ILEAPBranch** Value);
        [id(0x00000120), propget, helpstring("Adds a new named Transformation module. Parameters: IsSimple indicates simple or standard module; UseEfficiencies: indicates efficiencies entered as % efficiency or %losses; UseCapacities: whether module includes capacity data; UseLoadCurve: whether module includes load curve; UseCoProd: whether module has a co-product; UseOutputShares: whether module includes data in outputs shares (or outputs proportional to requirements; MeetAuxFromOutputs: whether module tries to meet auxiliary fuel needs from outputs; CoProductFuel: the co-product fuel (a fuel object or fuel ID); OutputUnit: unit used to measure historical production; Capacity Unit: unit used to measure capacity variables. ")]
        HRESULT AddModule(
                        [in] BSTR Name, 
                        [in] VARIANT_BOOL IsSimple, 
                        [in] VARIANT_BOOL UseEfficiencies, 
                        [in] VARIANT_BOOL UseCapacities, 
                        [in] VARIANT_BOOL UseLoadCurve, 
                        [in] VARIANT_BOOL UseCoProd, 
                        [in] VARIANT_BOOL UseOutputShares, 
                        [in] VARIANT_BOOL MeetAuxFromOutputs, 
                        [in] VARIANT CoProductFuel, 
                        [in] VARIANT OutputScale, 
                        [in] VARIANT OutputUnit, 
                        [in] VARIANT CapacityScale, 
                        [in] VARIANT CapacityUnit, 
                        [out, retval] ILEAPBranch** Value);
        [id(0x00000121), propget, helpstring("Adds a new Transformation output fuel under a branch with ID ParentID.  Fuel is a text parameter indicating the first feedstock fuel of the process.  ParentID is an integer parameter, which must refer to an Output category branch.")]
        HRESULT AddOutput(
                        [in] int ParentID, 
                        [in] VARIANT Fuel, 
                        [in] int ShortfallImport, 
                        [in] int SurplusExport, 
                        [in] int DomesticPriority, 
                        [in] VARIANT_BOOL IsPriorityFuel, 
                        [out, retval] ILEAPBranch** Value);
        [id(0x00000122), propget, helpstring("Gets the collection of all user variables.  Returns a LEAPUserVariables collection.")]
        HRESULT UserVariables([out, retval] ILEAPUserVariables** Value);
        [id(0x00000123), propget, helpstring("Gets the collection of all effects.  Returns a LEAPEffects collection.")]
        HRESULT Effects([out, retval] ILEAPEffects** Value);
        [id(0x00000127), propget, helpstring("Adds a new feedstock branch as a child of branch ParentID.  The Fuel parameter is a text parameter indicating the fuel associated with the branch.")]
        HRESULT AddFeedstock(
                        [in] int ParentID, 
                        [in] VARIANT Fuel, 
                        [out, retval] LEAPBranch** Value);
        [id(0x00000128), propget, helpstring("Gets the collection of all TEd technologies.  Returns a TEDTechnologies collection.")]
        HRESULT TEDTechnologies([out, retval] ITEDTechnologies** Value);
        [id(0x0000012b), helpstring("Deletes the file specified by Filename.")]
        HRESULT DeleteFile([in] BSTR FileName);
        [id(0x0000012c), helpstring("Disables the main user interface controls in LEAP such as the tree, data grid and chart: makes intensive data processing in LEAP much faster. (See also enablecontrols).")]
        HRESULT DisableControls();
        [id(0x0000012d), helpstring("Enables the main user interface controls in LEAP. Use in paired statements with disablecontrols.")]
        HRESULT EnableControls();
        [id(0x0000012a), propget, helpstring("Adds a new key assumption branch with name BName and the specified scale and units below branch ParentID.")]
        HRESULT AddKeyAssumption(
                        [in] int ParentID, 
                        [in] VARIANT BName, 
                        [in] VARIANT Scale, 
                        [in] VARIANT KUnit, 
                        [out, retval] ILEAPBranch** Value);
        [id(0x0000012e), propget, helpstring("Adds a new key assumption category branch with name BName below branch ParentID.")]
        HRESULT AddKeyAssumptionCategory(
                        [in] int ParentID, 
                        [in] VARIANT BName, 
                        [out, retval] ILEAPBranch** Value);
        [id(0x0000012f), propget, helpstring("Adds a new non energy sector branch with name BName and the specified scale and units below branch ParentID and with the specified effect.")]
        HRESULT AddNonEnergySectorEffect(
                        [in] int ParentID, 
                        [in] VARIANT BName, 
                        [in] VARIANT Scale, 
                        [in] VARIANT KUnit, 
                        [in] VARIANT Effect, 
                        [out, retval] ILEAPBranch** Value);
        [id(0x00000130), propget, helpstring("Adds a new non energy sector effect categrory with name BName below branch ParentID.")]
        HRESULT AddNonEnergySectorCategory(
                        [in] int ParentID, 
                        [in] VARIANT BName, 
                        [out, retval] ILEAPBranch** Value);
        [id(0x00000131), propget, helpstring("Adds a new set of emission factor branches corresponding to the technology in TED TEDID below branch ParentID.")]
        HRESULT AddTEDEffects(
                        [in] VARIANT ParentID, 
                        [in] VARIANT TEDID, 
                        [out, retval] ILEAPBranch** Value);
        [id(0x00000132), propget, helpstring("Returns a TED technology object given its unique ID number.")]
        HRESULT TEDTechnology(
                        [in] VARIANT TEDID, 
                        [out, retval] ITEDTechnology** Value);
        [id(0x00000129), propget, helpstring("Gets the LEAP resource branch object corresponding to the specified fuel.")]
        HRESULT ResourceBranchFromFuel(
                        [in] VARIANT FuelName, 
                        [out, retval] ILEAPBranch** Value);
        [id(0x00000133), propget, helpstring("Obsolete. Please use LEAP.Effects("EffectName") instead.")]
        HRESULT Effect(
                        [in] VARIANT EffectName, 
                        [out, retval] ILEAPEffect** Value);
        [id(0x00000134), propget, helpstring("Gets or sets the first year in which fossil fuel reserves are depleted in calculations.")]
        HRESULT FirstDepletionYear([out, retval] long* Value);
        [id(0x00000134), propput, helpstring("Gets or sets the first year in which fossil fuel reserves are depleted in calculations.")]
        HRESULT FirstDepletionYear([in] long Value);
        [id(0x00000135), propget, helpstring("Gets the LEAP statistical difference branch object corresponding to the specified fuel.")]
        HRESULT StatDiffBranchFromFuel(
                        [in] VARIANT FuelName, 
                        [out, retval] ILEAPBranch** Value);
        [id(0x00000136), propget, helpstring("Gets the LEAP stock change branch object corresponding to the specified fuel.")]
        HRESULT StockChangeBranchFromFuel(
                        [in] VARIANT FuelName, 
                        [out, retval] ILEAPBranch** Value);
        [id(0x00000137), propget, helpstring("Gets or sets whether statistical difference branches are visible and included in calculations.")]
        HRESULT ShowStatDiffs([out, retval] VARIANT_BOOL* Value);
        [id(0x00000137), propput, helpstring("Gets or sets whether statistical difference branches are visible and included in calculations.")]
        HRESULT ShowStatDiffs([in] VARIANT_BOOL Value);
        [id(0x00000138), propget, helpstring("Gets or sets whether cost variables are visible and included in calculations.")]
        HRESULT ShowCosts([out, retval] VARIANT_BOOL* Value);
        [id(0x00000138), propput, helpstring("Gets or sets whether cost variables are visible and included in calculations.")]
        HRESULT ShowCosts([in] VARIANT_BOOL Value);
        [id(0x00000139), propget, helpstring("Gets or sets whether non-energy sector emissions branches are visible and included in calculations.")]
        HRESULT ShowNonEnergy([out, retval] VARIANT_BOOL* Value);
        [id(0x00000139), propput, helpstring("Gets or sets whether non-energy sector emissions branches are visible and included in calculations.")]
        HRESULT ShowNonEnergy([in] VARIANT_BOOL Value);
        [id(0x0000013a), propget, helpstring("Gets or sets whether indicator branches are visible.")]
        HRESULT ShowIndicators([out, retval] VARIANT_BOOL* Value);
        [id(0x0000013a), propput, helpstring("Gets or sets whether indicator branches are visible.")]
        HRESULT ShowIndicators([in] VARIANT_BOOL Value);
        [id(0x0000013c), propget, helpstring("Adds a new useful energy intensity branch to the tree with name BName.  Adds the branch as a child to the existing branch with branch ID ParentID.  The Scale and ActivityUnit parameters are text parameters.")]
        HRESULT AddUsefulIntensity(
                        [in] int ParentID, 
                        [in] BSTR BName, 
                        [in] VARIANT Scale, 
                        [in] VARIANT AcUnit, 
                        [out, retval] ILEAPBranch** Value);
        [id(0x0000013b), propget, helpstring("Adds a new aggregate energy intensity branch to the tree with name BName.  Adds the branch as a child to the existing branch with branch ID ParentID. The Scale and ActivityUnit parameters are text parameters.")]
        HRESULT AddAggregateIntensity(
                        [in] int ParentID, 
                        [in] BSTR BName, 
                        [in] VARIANT Scale, 
                        [in] VARIANT AcUnit, 
                        [in] VARIANT EnergyUnit, 
                        [out, retval] ILEAPBranch** Value);
        [id(0x0000013d), propget, helpstring("Gets or sets the columns displayed in an energy balance table.  Specified as an integer from 0 to 4, where  0=fuel group (balance category), 1=fuel, 2=year, 3=region, 4=region group.")]
        HRESULT EnergyBalanceColumns([out, retval] long* Value);
        [id(0x0000013d), propput, helpstring("Gets or sets the columns displayed in an energy balance table.  Specified as an integer from 0 to 4, where  0=fuel group (balance category), 1=fuel, 2=year, 3=region, 4=region group.")]
        HRESULT EnergyBalanceColumns([in] long Value);
        [id(0x0000013e), helpstring("Exports the current energy balance to the specified CSV format filename.")]
        HRESULT ExportEnergyBalanceCSV([in] BSTR FileName);
        [id(0x0000013f), helpstring("Exports the current energy balance to Excel.")]
        HRESULT ExportEnergyBalanceXLS();
        [id(0x00000140), helpstring("Copies the current energy balance table to the Windows clipboard.")]
        HRESULT CopyEnergyBalanceTable();
        [id(0x00000141), helpstring("Copies the current energy balance chart to the Windows clipboard.")]
        HRESULT CopyEnergyBalanceChart();
        [id(0x00000142), propget, helpstring("Gets or sets the unit for an energy balance. Deprecated. Use LEAP.ActiveUnit instead.")]
        HRESULT EnergyBalanceUnit([out, retval] ILEAPUnit** Value);
        [id(0x00000142), propput, helpstring("Gets or sets the unit for an energy balance. Deprecated. Use LEAP.ActiveUnit instead.")]
        HRESULT EnergyBalanceUnit([in] ILEAPUnit* Value);
        [id(0x00000143), propget, helpstring("Gets or sets the unit for an energy balance by ID. Deprecated. Use LEAP.ActiveUnit instead.")]
        HRESULT EnergyBalanceUnitID([out, retval] int* Value);
        [id(0x00000143), propput, helpstring("Gets or sets the unit for an energy balance by ID. Deprecated. Use LEAP.ActiveUnit instead.")]
        HRESULT EnergyBalanceUnitID([in] int Value);
        [id(0x00000144), propget, hidden, helpstring("Gets or sets the scenario for an energy balance by ID. Deprecated. Use LEAP.ActiveScenario instead.")]
        HRESULT EnergyBalanceScenarioID([out, retval] int* Value);
        [id(0x00000144), propput, hidden, helpstring("Gets or sets the scenario for an energy balance by ID. Deprecated. Use LEAP.ActiveScenario instead.")]
        HRESULT EnergyBalanceScenarioID([in] int Value);
        [id(0x00000145), propget, helpstring("Gets or sets the scenario for an energy balance. Deprecated. Use LEAP.ActiveScenario instead.")]
        HRESULT EnergyBalanceScenario([out, retval] ILEAPScenario** Value);
        [id(0x00000145), propput, helpstring("Gets or sets the scenario for an energy balance. Deprecated. Use LEAP.ActiveScenario instead.")]
        HRESULT EnergyBalanceScenario([in] ILEAPScenario* Value);
        [id(0x00000146), propget, helpstring("Gets or sets the year for an energy balance. Deprecated. Use LEAP.ActiveYear instead.")]
        HRESULT EnergyBalanceYear([out, retval] long* Value);
        [id(0x00000146), propput, helpstring("Gets or sets the year for an energy balance. Deprecated. Use LEAP.ActiveYear instead.")]
        HRESULT EnergyBalanceYear([in] long Value);
        [id(0x00000147), propget, helpstring("Gets or sets the region for an energy balance. Deprecated. Use LEAP.ActiveRegion instead.")]
        HRESULT EnergyBalanceRegion([out, retval] ILEAPRegion** Value);
        [id(0x00000147), propput, helpstring("Gets or sets the region for an energy balance. Deprecated. Use LEAP.ActiveRegion instead.")]
        HRESULT EnergyBalanceRegion([in] ILEAPRegion* Value);
        [id(0x00000148), propget, hidden, helpstring("Gets or sets the region for an energy balance by ID. Deprecated. Use LEAP.ActiveRegion instead.")]
        HRESULT EnergyBalanceRegionID([out, retval] int* Value);
        [id(0x00000148), propput, hidden, helpstring("Gets or sets the region for an energy balance by ID. Deprecated. Use LEAP.ActiveRegion instead.")]
        HRESULT EnergyBalanceRegionID([in] int Value);
        [id(0x00000149), propget, helpstring("Gets or sets the maximumum number of iterations to solve Transformation calculations.  If exceeded without calculations converging, the calculation will fail.")]
        HRESULT MaxIterations([out, retval] long* Value);
        [id(0x00000149), propput, helpstring("Gets or sets the maximumum number of iterations to solve Transformation calculations.  If exceeded without calculations converging, the calculation will fail.")]
        HRESULT MaxIterations([in] long Value);
        [id(0x0000014a), propget, helpstring("Gets or sets whether LEAP should check for surplus production in Transformation calculations.")]
        HRESULT CheckSurplusProduction([out, retval] VARIANT_BOOL* Value);
        [id(0x0000014a), propput, helpstring("Gets or sets whether LEAP should check for surplus production in Transformation calculations.")]
        HRESULT CheckSurplusProduction([in] VARIANT_BOOL Value);
        [id(0x0000014b), propget, helpstring("Gets or sets whether LEAP should check for unmet requirements in Transformation calculations.")]
        HRESULT CheckUnmetRequirements([out, retval] VARIANT_BOOL* Value);
        [id(0x0000014b), propput, helpstring("Gets or sets whether LEAP should check for unmet requirements in Transformation calculations.")]
        HRESULT CheckUnmetRequirements([in] VARIANT_BOOL Value);
        [id(0x0000014c), propget, helpstring("Gets or sets whether LEAP should allow growth rate expressions to be applied to share values.")]
        HRESULT AllowGrowthOnShares([out, retval] VARIANT_BOOL* Value);
        [id(0x0000014c), propput, helpstring("Gets or sets whether LEAP should allow growth rate expressions to be applied to share values.")]
        HRESULT AllowGrowthOnShares([in] VARIANT_BOOL Value);
        [id(0x0000014d), propget, helpstring("Gets or sets whether LEAP should efficiency values of over 100%.")]
        HRESULT AllowEfficienciesOver100([out, retval] VARIANT_BOOL* Value);
        [id(0x0000014d), propput, helpstring("Gets or sets whether LEAP should efficiency values of over 100%.")]
        HRESULT AllowEfficienciesOver100([in] VARIANT_BOOL Value);
        [id(0x0000014e), propget, helpstring("Gets or sets whether LEAP should check that share values sum to 100% across neighboring branches.")]
        HRESULT DontCheckShares([out, retval] VARIANT_BOOL* Value);
        [id(0x0000014e), propput, helpstring("Gets or sets whether LEAP should check that share values sum to 100% across neighboring branches.")]
        HRESULT DontCheckShares([in] VARIANT_BOOL Value);
        [id(0x0000014f), propget, helpstring("Gets or sets whether LEAP should allow expressions to reference lagged results.  Setting this to true will slow down calculations.")]
        HRESULT AllowLaggedResults([out, retval] VARIANT_BOOL* Value);
        [id(0x0000014f), propput, helpstring("Gets or sets whether LEAP should allow expressions to reference lagged results.  Setting this to true will slow down calculations.")]
        HRESULT AllowLaggedResults([in] VARIANT_BOOL Value);
        [id(0x00000150), propget, helpstring("Gets or sets the active year in the results and energy balance views.")]
        HRESULT ActiveYear([out, retval] long* Value);
        [id(0x00000150), propput, helpstring("Gets or sets the active year in the results and energy balance views.")]
        HRESULT ActiveYear([in] long Value);
        [id(0x00000115), propget, helpstring("Gets or sets the active year in the results or energy balance view.")]
        HRESULT ActiveUnit([out, retval] VARIANT* Value);
        [id(0x00000115), propput, helpstring("Gets or sets the active year in the results or energy balance view.")]
        HRESULT ActiveUnit([in] VARIANT Value);
        [id(0x00000151), helpstring("Save the current results view chart in the specified format and filename and with the specified title and subtitle captions. If the title and subtitle are left blank, LEAP will use the default auto-generated titles and subtitles. File format is an integer indicating the format of the file.  See help file for details of supported file formats.")]
        HRESULT SaveResultsChart(
                        [in] BSTR FileName, 
                        [in, optional, defaultvalue(2)] long FileFormat, 
                        [in, optional, defaultvalue("")] BSTR TitleCap, 
                        [in, optional, defaultvalue("")] BSTR SubTitleCap);
        [id(0x00000152), propget, helpstring("Gets or sets the dimension for the Results Chart X Axis.")]
        HRESULT ResultsXAxis([out, retval] VARIANT* Value);
        [id(0x00000152), propput, helpstring("Gets or sets the dimension for the Results Chart X Axis.")]
        HRESULT ResultsXAxis([in] VARIANT Value);
        [id(0x00000153), propget, helpstring("Gets or sets the dimension for the Results Chart legend.")]
        HRESULT ResultsLegend([out, retval] VARIANT* Value);
        [id(0x00000153), propput, helpstring("Gets or sets the dimension for the Results Chart legend.")]
        HRESULT ResultsLegend([in] VARIANT Value);
        [id(0x00000154), propget, helpstring("Gets the collection of all dimensions.")]
        HRESULT Dimensions([out, retval] ILEAPDimensions** Value);
        [id(0x00000155), propget, helpstring("Adds a new simple process to the tree with name BName.  Adds the branch as a child to the existing branch with branch ID ParentID. Inputfuel and Outputfuel are the input and output fuels of the process specifed as text, ID or LEAPFuel objects.")]
        HRESULT AddSimpleProcess(
                        [in] int ParentID, 
                        [in] BSTR BName, 
                        [in] VARIANT InputFuel, 
                        [in] VARIANT OutputFuel, 
                        [out, retval] ILEAPBranch** Value);
        [id(0x00000156), propget, helpstring("Gets or sets the visibility of the top level area branch in the Analysis view.  This branch is always visible in Results view.")]
        HRESULT ShowAreaBranch([out, retval] VARIANT_BOOL* Value);
        [id(0x00000156), propput, helpstring("Gets or sets the visibility of the top level area branch in the Analysis view.  This branch is always visible in Results view.")]
        HRESULT ShowAreaBranch([in] VARIANT_BOOL Value);
        [id(0x00000157), helpstring("Renames a file. Parameters are the old and new fully qualified file names.")]
        HRESULT RenameFile(
                        [in] BSTR OldFilename, 
                        [in] BSTR NewFilename);
        [id(0x00000158), helpstring("Copies a file. Parameters are the source file name and the destination path.")]
        HRESULT CopyFile(
                        [in] BSTR FromFilename, 
                        [in] BSTR ToFilename);
        [id(0x00000159), helpstring("Creates a directory. Parameter is the directory path.")]
        HRESULT CreateDirectory([in] BSTR Directoryname);
        [id(0x000000cd), propget, helpstring("Gets the collection of all LEAP timeslices.")]
        HRESULT TimeSlices([out, retval] ILEAPTimeSlices** Value);
        [id(0x00000124), propget, helpstring("Gets the collection of yearly shapes defined for the area.")]
        HRESULT YearlyShapes([out, retval] ILEAPYearlyShapes** Value);
        [id(0x00000125), propget, helpstring("Indicates if the GNU math program, required by OSeMOSYS, is installed.")]
        HRESULT GNUMathProgInstalled([out, retval] VARIANT_BOOL* Value);
        [id(0x00000126), propget, helpstring("Indicates if the Borland Database Engine (BDE) is installed. Used only by older (Pre-2008) versions of LEAP.")]
        HRESULT BDEInstalled([out, retval] VARIANT_BOOL* Value);
        [id(0x0000015a), propget, helpstring("Indicates if WEAP is installed.  WEAP is the sister software to LEAP for water planning.")]
        HRESULT WEAPInstalled([out, retval] VARIANT_BOOL* Value);
        [id(0x0000015b), propget, helpstring("Gets the linkage to WEAP (Used primarily when WEAP and LEAP are run connected to each other).")]
        HRESULT WEAPLinkage([out, retval] AutoWEAPLinkage** Value);
        [id(0x0000015c), propget, hidden, helpstring("Get the compiled code for a branch:variable[scale unit] reference.  Called by WEAP.")]
        HRESULT CompileVarRef(
                        [in] BSTR UncompiledVarRef, 
                        [out, retval] BSTR* Value);
        [id(0x0000015d), propget, hidden, helpstring("Uncompile the compiled expression into branch:variable[scale unit] format.  Called by LEAP.")]
        HRESULT UncompileVarRef(
                        [in] BSTR CompiledVarRef, 
                        [out, retval] BSTR* Value);
        [id(0x0000015e), helpstring("Refreshes the resource list (first puts LEAP into Analysis View). Not normally required by user.")]
        HRESULT RefreshResources();
        [id(0x0000015f), propget, helpstring("Gets whether LEAP can close down and preps for close down.  Follow by setting LEAP object to nil.")]
        HRESULT CanQuit([out, retval] VARIANT_BOOL* Value);
        [id(0x00000160), propget, helpstring("Returns the string wrapped in Quote marks (if necessary).  ")]
        HRESULT Quote(
                        [in] BSTR InStr, 
                        [out, retval] BSTR* Value);
        [id(0x00000161), propget, helpstring("Adds a new demand technology branch (using the Total method) to the tree with name BName.  Adds the branch as a child to branch ParentID.   The Fuel parameter is a text parameter indicating the fuel associated with the branch.  The EnergyUnit parameter indicates the unit of measurement of the total energy variable.  ParentID is an integer parameter, which must refer to a demand category branch.")]
        HRESULT AddTotalTechnology(
                        [in] int ParentID, 
                        [in] BSTR BName, 
                        [in] VARIANT Fuel, 
                        [in] VARIANT EnergyUnit, 
                        [out, retval] ILEAPBranch** Value);
        [id(0x00000162), propget, helpstring("Adds a new indicator branch to the tree with name BName.  Adds the branch as a child to branch ParentID.   ")]
        HRESULT AddIndicator(
                        [in] int ParentID, 
                        [in] VARIANT BName, 
                        [in] VARIANT Scale, 
                        [in] VARIANT KUnit, 
                        [out, retval] ILEAPBranch** Value);
        [id(0x00000163), propget, helpstring("Adds a new indicator category branch to the tree with name BName.  Adds the branch as a child to branch ParentID.   ")]
        HRESULT AddIndicatorCategory(
                        [in] int ParentID, 
                        [in] VARIANT BName, 
                        [out, retval] ILEAPBranch** Value);
        [id(0x00000164), propget, helpstring("Saves a favorite with name FaveName in folder FolderName using the current Results view settings")]
        HRESULT SaveFavorite(
                        [in] VARIANT FolderName, 
                        [in] VARIANT FaveName, 
                        [out, retval] LEAPFavorite** Value);
        [id(0x00000165), helpstring("Exports the current results view chart.  If the title and subtitle are left blank, LEAP will use the default auto-generated titles and subtitles.")]
        HRESULT ExportResults(
                        [in, defaultvalue("")] BSTR Title, 
                        [in, defaultvalue("")] BSTR Subtitle, 
                        [in, defaultvalue(0)] int FileFormat, 
                        [in, optional, defaultvalue("")] BSTR FileName, 
                        [in, optional, defaultvalue(1)] int Resolution);
        [id(0x00000166), propget, helpstring("Returns true if the running copy of LEAP is fully registered (licensed).")]
        HRESULT Registered([out, retval] VARIANT_BOOL* Value);
        [id(0x00000167), propget, helpstring("Returns true if the running copy of LEAP has been registered online (i.e. is regsitered with the LEAP website).")]
        HRESULT RegisteredOnline([out, retval] VARIANT_BOOL* Value);
        [id(0x00000168), helpstring("Refresh the screen display.")]
        HRESULT Refresh();
        [id(0x00000169), propget, helpstring("Gets the entire area-wide collection of tags.")]
        HRESULT Tags([out, retval] ILEAPTags** Value);
        [id(0x0000016a), propget, helpstring("Gets the full path of the LEAP dictionary directory.")]
        HRESULT DictionaryDirectory([out, retval] BSTR* Value);
        [id(0x0000016b), propget, helpstring("Gets or sets the filename for the script that occurs after each scenario is calculated (if any).")]
        HRESULT AfterScenarioCalc([out, retval] BSTR* Value);
        [id(0x0000016b), propput, helpstring("Gets or sets the filename for the script that occurs after each scenario is calculated (if any).")]
        HRESULT AfterScenarioCalc([in] BSTR Value);
        [id(0x0000016d), propget, helpstring("Returns one of the sets of fuel groups (1..NumFuelGroupSets). Returns a FuelGroups object.")]
        HRESULT FuelGroupSets(
                        [in] int Index, 
                        [out, retval] LEAPFuelGroups** Result);
        [id(0x0000016c), propget, helpstring("Returns the number of fuel group sets in the area (max 4).")]
        HRESULT NumFuelGroupSets([out, retval] int* Value);
        [id(0x0000016e), propget, helpstring("Returns one of the sets of region groups (1..NumRegionGroupSets). Returns a RegionGroups object.")]
        HRESULT RegionGroupSets(
                        [in] int Index, 
                        [out, retval] LEAPRegionGroups** Value);
        [id(0x0000016f), propget, helpstring("Returns the number of region group sets in the area (max 4).")]
        HRESULT NumRegionGroupSets([out, retval] int* Value);
        [id(0x00000170), propget, helpstring("Gets or sets the interval in years for calculation of results. Results will then only be saved if the year is divisible by this value.")]
        HRESULT ResultsEvery([out, retval] long* Value);
        [id(0x00000170), propput, helpstring("Gets or sets the interval in years for calculation of results. Results will then only be saved if the year is divisible by this value.")]
        HRESULT ResultsEvery([in] long Value);
        [id(0x00000171), propget, helpstring("Gets or sets whether land-based resource data are visibled and included in calculations.")]
        HRESULT ShowLandResources([out, retval] VARIANT_BOOL* Value);
        [id(0x00000171), propput, helpstring("Gets or sets whether land-based resource data are visibled and included in calculations.")]
        HRESULT ShowLandResources([in] VARIANT_BOOL Value);
        [id(0x00000172), propget, helpstring("Gets or sets whether energy sector emissions branches are visible and included in calculations.")]
        HRESULT ShowEnergyEffects([out, retval] VARIANT_BOOL* Value);
        [id(0x00000172), propput, helpstring("Gets or sets whether energy sector emissions branches are visible and included in calculations.")]
        HRESULT ShowEnergyEffects([in] VARIANT_BOOL Value);
        [id(0x00000173), propget, helpstring("Gets or sets whether complex effects (other than major GHGs and air pollutants) are visible and included in calculations.")]
        HRESULT ShowComplexEffects([out, retval] VARIANT_BOOL* Value);
        [id(0x00000173), propput, helpstring("Gets or sets whether complex effects (other than major GHGs and air pollutants) are visible and included in calculations.")]
        HRESULT ShowComplexEffects([in] VARIANT_BOOL Value);
        [id(0x00000174), propget, helpstring("Gets or sets the scale of an area: 0=National,1=Subnational,2=Multinational,3=Global,4=Undefined. For info only. Does not affect calculations.")]
        HRESULT AreaScale([out, retval] long* Value);
        [id(0x00000174), propput, helpstring("Gets or sets the scale of an area: 0=National,1=Subnational,2=Multinational,3=Global,4=Undefined. For info only. Does not affect calculations.")]
        HRESULT AreaScale([in] long Value);
        [id(0x00000175), propget, helpstring("Gets or sets the name of a country associated with an area (only for national and subnational scale areas).")]
        HRESULT AreaCountry([out, retval] BSTR* Value);
        [id(0x00000175), propput, helpstring("Gets or sets the name of a country associated with an area (only for national and subnational scale areas).")]
        HRESULT AreaCountry([in] BSTR Value);
        [id(0x00000176), propget, helpstring("Gets or sets whether to save all results or to save only those selected in the General: Results to Save screen.")]
        HRESULT AllResultsSaved([out, retval] VARIANT_BOOL* Value);
        [id(0x00000176), propput, helpstring("Gets or sets whether to save all results or to save only those selected in the General: Results to Save screen.")]
        HRESULT AllResultsSaved([in] VARIANT_BOOL Value);
        [id(0x00000177), propget, helpstring("In multi-region areas, gets or sets assumption of no endogenously calculated imports or exports among area's regions: all imports come from rest of world.")]
        HRESULT AssumeNoRegionalTrade([out, retval] VARIANT_BOOL* Value);
        [id(0x00000177), propput, helpstring("In multi-region areas, gets or sets assumption of no endogenously calculated imports or exports among area's regions: all imports come from rest of world.")]
        HRESULT AssumeNoRegionalTrade([in] VARIANT_BOOL Value);
        [id(0x00000178), propget, helpstring("Gets or sets whether LEAP shows calculation progress (causing slower calculations): 0=Only Large Areas, 1=Always, 2=Never.")]
        HRESULT ShowCalcProgress([out, retval] long* Value);
        [id(0x00000178), propput, helpstring("Gets or sets whether LEAP shows calculation progress (causing slower calculations): 0=Only Large Areas, 1=Always, 2=Never.")]
        HRESULT ShowCalcProgress([in] long Value);
        [id(0x00000179), propget, helpstring("Gets the LEAP software version as a floating point value (e.g. 2018.001)")]
        HRESULT SoftwareVersionValue([out, retval] double* Value);
        [id(0x0000017a), propget, helpstring("gets the collection of all countries/economies. ")]
        HRESULT Countries([out, retval] ILEAPCountries** Value);
        [id(0x0000017b), propget, helpstring("Gets the collection of all landtypes.")]
        HRESULT LandTypes([out, retval] ILEAPLandTypes** Value);
        [id(0x0000017c), propget, helpstring("Gets or sets whether IBC extension is included in calculations.")]
        HRESULT ShowIBC([out, retval] VARIANT_BOOL* Value);
        [id(0x0000017c), propput, helpstring("Gets or sets whether IBC extension is included in calculations.")]
        HRESULT ShowIBC([in] VARIANT_BOOL Value);
        [id(0x0000017d), helpstring("Displays the LEAP progress bar and sets percent complete on bar to 0%.  Also sets bar and panel captions.")]
        HRESULT ShowProgressBar(
                        [in, defaultvalue("")] BSTR BarCaption, 
                        [in, defaultvalue("")] BSTR PanelCaption);
        [id(0x0000017e), helpstring("Closes the LEAP progress bar.")]
        HRESULT CloseProgressBar();
        [id(0x0000017f), helpstring("Sets the percent complete of the LEAP progress bar. Optional parameter to change panel caption. ")]
        HRESULT SetProgressBar(
                        [in] long Value, 
                        [in, optional, defaultvalue("")] BSTR PanelCaption);
        [id(0x00000180), helpstring("Sleeps (pauses) LEAP for the set number of milliseconds. Max 10000 milliseconds.")]
        HRESULT Sleep([in] long Value);
        [id(0x00000181), propget, helpstring("The mean annual relative risk of premature mortality for a PM2.5 pollutant concentration and disease (COPD, LC, STROKE, IHD). IHD and stroke use an age parameter.")]
        HRESULT PollutionRelRiskMean(
                        [in] int ScenarioID, 
                        [in] int EffectID, 
                        [in] int DiseaseID, 
                        [in] int Age, 
                        [in] double Concentration, 
                        [out, retval] double* Value);
        [id(0x00000182), propget, helpstring("A statistical measure of annual relative risk of premature mortality for a particular PM2.5 pollutant concentration and disease (COPD, LC, STROKE, IHD). ")]
        HRESULT PollutionRelRisk(
                        [in] int ScenarioID, 
                        [in] int EffectID, 
                        [in] int DiseaseID, 
                        [in] int StatisticID, 
                        [in] int Age, 
                        [in] double Concentration, 
                        [out, retval] double* Value);
        [id(0x00000183), propget, helpstring("The branch from which the API was called in a CALL function. (Read Only)")]
        HRESULT ScriptContextBranch([out, retval] ILEAPBranch** Value);
        [id(0x00000184), propget, helpstring("The variable from which the API was called in a CALL function. (Read Only)")]
        HRESULT ScriptContextVariable([out, retval] ILEAPVariable** Value);
        [id(0x00000185), propget, helpstring("The scenario from which the API was called in a CALL function. (Read Only)")]
        HRESULT ScriptContextScenario([out, retval] ILEAPScenario** Value);
        [id(0x00000186), propget, helpstring("The region from which the API was called in a CALL function. (Read Only)")]
        HRESULT ScriptContextRegion([out, retval] ILEAPRegion** Value);
        [id(0x00000187), propget, helpstring("The year associated with a script being called from a CALL function: the active year at the time the function was called. (Read Only)")]
        HRESULT ScriptContextYear([out, retval] int* Value);
        [id(0x00000188), propget, helpstring("The unique Time Slice ID associated with a script being called from a CALL function: the active time slice at the time the function was called. (Read Only)")]
        HRESULT ScriptContextTimeSliceID([out, retval] int* Value);
        [id(0x00000189), propget, helpstring("Adds a new land conversion branch to the tree as a child to branch ParentID.   Specify source and destination land types (to/from) for conversion.")]
        HRESULT AddLandConversion(
                        [in] int ParentID, 
                        [in] VARIANT FromLandType, 
                        [in] VARIANT ToLandType, 
                        [out, retval] ILEAPBranch** Value);
        [id(0x0000018a), propget, helpstring("Adds a new auxiliary fuel branch as a child to branch ParentID. Parameters are: Fuel: the aux fuel (ID or object); NumUnit: numerator unit (object or ID); DenomUnit: denominator unit (ID or object); Method (0=per unit of energy consumed,1=per unit of energy produced).")]
        HRESULT AddAuxiliary(
                        [in] int ParentID, 
                        [in] VARIANT Fuel, 
                        [in] VARIANT NumUnit, 
                        [in] VARIANT DenomUnit, 
                        [in] int Method, 
                        [out, retval] ILEAPBranch** Value);
        [id(0x0000018c), propget, helpstring("Gets or sets ID of region associated with main city used in an urban LEAP-IBC calculation.  Requires IBC and UrbanIBC settings to also be enabled.")]
        HRESULT UrbanIBCCityRegionID([out, retval] int* Value);
        [id(0x0000018c), propput, helpstring("Gets or sets ID of region associated with main city used in an urban LEAP-IBC calculation.  Requires IBC and UrbanIBC settings to also be enabled.")]
        HRESULT UrbanIBCCityRegionID([in] int Value);
        [id(0x0000018d), propget, helpstring("Gets or sets whether urban version of IBC calculations are used. Requires IBC to be enabled and regional data set with at least two regions. Only works for subset of countries.")]
        HRESULT ShowUrbanIBC([out, retval] VARIANT_BOOL* Value);
        [id(0x0000018d), propput, helpstring("Gets or sets whether urban version of IBC calculations are used. Requires IBC to be enabled and regional data set with at least two regions. Only works for subset of countries.")]
        HRESULT ShowUrbanIBC([in] VARIANT_BOOL Value);
        [id(0x0000018e), propget, helpstring("Gets region associated with main city used in an urban LEAP-IBC calculation.  Requires ShowIBC and ShowUrbanIBC settings to be enabled. (Read Only)")]
        HRESULT UrbanIBCCityRegion([out, retval] ILEAPRegion** Value);
        [id(0x0000018b), propget, helpstring("Gets or sets whether indoor air pollution calculations are included.  Requires IBC to be enabled.")]
        HRESULT ShowIndoorAirPollution([out, retval] VARIANT_BOOL* Value);
        [id(0x0000018b), propput, helpstring("Gets or sets whether indoor air pollution calculations are included.  Requires IBC to be enabled.")]
        HRESULT ShowIndoorAirPollution([in] VARIANT_BOOL Value);
        [id(0x0000018f), helpstring("Show the chart/table split view in Results view.")]
        HRESULT ShowResultsViewSplit();
        [id(0x00000190), propget, helpstring("Set the yearly interval for displaying results in the Results View screen.")]
        HRESULT ResultsViewYearlyInterval([out, retval] int* Value);
        [id(0x00000190), propput, helpstring("Set the yearly interval for displaying results in the Results View screen.")]
        HRESULT ResultsViewYearlyInterval([in] int Value);
        [id(0x00000191), propget, helpstring("Gets or sets whether IBC's ozone health and vegetation calculations are used. Requires IBC to be enabled. Only works for subset of countries.")]
        HRESULT ShowIBCOzone([out, retval] VARIANT_BOOL* Value);
        [id(0x00000191), propput, helpstring("Gets or sets whether IBC's ozone health and vegetation calculations are used. Requires IBC to be enabled. Only works for subset of countries.")]
        HRESULT ShowIBCOzone([in] VARIANT_BOOL Value);
        [id(0x00000192), propget, helpstring("Adds a new energy sector effect branch below ParentID with name BName and with the specified scale, numerator, denominator, effect, & method. Methods: 0=perCons,1=perProd,2=perLost,3=perTrav,4=perCapacity,5=total. If Bname blank, assigns effect name to branch.")]
        HRESULT AddEffect(
                        [in] int ParentID, 
                        [in] VARIANT BName, 
                        [in] VARIANT Scale, 
                        [in] VARIANT NUnit, 
                        [in] VARIANT DUnit, 
                        [in] VARIANT Effect, 
                        [in] int Method, 
                        [out, retval] ILEAPBranch** Value);
        [id(0x00000193), propget, helpstring("Gets the collection of all LEAP constants.")]
        HRESULT Constants([out, retval] ILEAPConstants** Value);
        [id(0x00000194), propget, helpstring("Get a LEAP constant object from its name.")]
        HRESULT Constant(
                        [in] VARIANT Name, 
                        [out, retval] ILEAPConstant** Value);
        [id(0x00000195), propget, helpstring("Gets a country object.")]
        HRESULT Country(
                        [in] VARIANT Name, 
                        [out, retval] ILEAPCountry** Value);
        [id(0x00000196), propget, helpstring("Gets a YearlyShape object.")]
        HRESULT YearlyShape(
                        [in] VARIANT Name, 
                        [out, retval] ILEAPYearlyShape** Value);
        [id(0x00000197), propget, helpstring("Gets a Tag object.")]
        HRESULT Tag(
                        [in] VARIANT Name, 
                        [out, retval] ILEAPTag** Value);
        [id(0x00000198), helpstring("Force refresh of branches")]
        HRESULT RefreshBranches();
    };

    [
      odl,
      uuid(D572EAF0-FFAD-419A-8E33-DAEC23E96B00),
      version(1.0),
      helpstring("Dispatch Interface for LEAPScenarioObject"),
      dual,
      oleautomation
    ]
    interface ILEAPScenario : IDispatch {
        [id(00000000), propget, helpstring("The name of the scenario. Default property.")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(00000000), propput, helpstring("The name of the scenario. Default property.")]
        HRESULT Name([in] BSTR Value);
        [id(0x000000c9), propget, helpstring("The unique ID of the scenario.")]
        HRESULT ID([out, retval] int* ScenID);
        [id(0x000000ca), hidden]
        HRESULT Init([in] int ScenarioID);
        [id(0x000000cb), propget, helpstring("Gets or sets whether results will be shown for the scenario in the Results View.")]
        HRESULT ResultsShown([out, retval] VARIANT_BOOL* Value);
        [id(0x000000cb), propput, helpstring("Gets or sets whether results will be shown for the scenario in the Results View.")]
        HRESULT ResultsShown([in, optional, defaultvalue(0)] VARIANT_BOOL Value);
        [id(0x000000cd), propget, helpstring("Gets or sets whether results will be shown for the scenario in the Results View.")]
        HRESULT IsCurrentAccounts([out, retval] VARIANT_BOOL* Value);
        [id(0x000000ce), propget, helpstring("Returns true if the scenario is the Current Accounts, otherwise false.")]
        HRESULT Active([out, retval] VARIANT_BOOL* Value);
        [id(0x000000ce), propput, helpstring("Returns true if the scenario is the Current Accounts, otherwise false.")]
        HRESULT Active([in] VARIANT_BOOL Value);
        [id(0x000000cc), propget, helpstring("The abbreviation for the scenario.")]
        HRESULT Abbreviation([out, retval] BSTR* Value);
        [id(0x000000cc), propput, helpstring("The abbreviation for the scenario.")]
        HRESULT Abbreviation([in] BSTR Value);
        [id(0x000000cf), propget, hidden, helpstring("The parent scenario upon which expressions for this scenario are based. Deprecated: Use "Parent" property.")]
        HRESULT BasedOn([out, retval] ILEAPScenario** Value);
        [id(0x000000d0), propget, hidden, helpstring("The unique ID of the scenario upon which expressions for this scenario are based. Deprecated: Use "Parent" property.")]
        HRESULT BasedOnID([out, retval] int* Value);
        [id(0x000000d1), propget, helpstring("The DateTime when the scenario was last edited.")]
        HRESULT LastChanged([out, retval] DATE* Value);
        [id(0x000000d2), propget, helpstring("The DateTime when the scenario was last calculated.")]
        HRESULT LastCalculated([out, retval] DATE* Value);
        [id(0x000000d3), propget, helpstring("Returns whether the scenario needs to be calculated.")]
        HRESULT NeedsCalculation([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d4), propget, helpstring("The index number of the scenario from 1..LEAP.Scenarios.Count.")]
        HRESULT Index([out, retval] int* Value);
        [id(0x000000d5), propget, helpstring("Gets or sets the parent scenario of the current scenario.  Returns a scenario branch object. Can be set equal to a scenario name, ID or a scenario object.")]
        HRESULT Parent([out, retval] VARIANT* Value);
        [id(0x000000d5), propput, helpstring("Gets or sets the parent scenario of the current scenario.  Returns a scenario branch object. Can be set equal to a scenario name, ID or a scenario object.")]
        HRESULT Parent([in] VARIANT Value);
        [id(0x000000d7), propget, helpstring("Gets the collection of the additional scenarios belonging to a scenario. These are the scenarios listed as "Additional scenarios" in the Scenario Manager screen. Use AdditionalScenarios.Count to find the number of additional scenarios associated with a scenario. This collection is used to manage multiple inheritance of expressions in scenarios.")]
        HRESULT AdditionalScenarios([out, retval] ILEAPScenarios** Value);
        [id(0x000000d6), helpstring("Add an additional scenario to the list of scenarios associated with the current scenario. Specify the scenario to be added by name or ID or as a scenario object. NB: Use the Scenarios collection "Add" method to create a new scenario.")]
        HRESULT AddAdditional([in] VARIANT Scenario);
        [id(0x000000d8), helpstring("Remove an existing scenario from the list of additonal scenarios associated with the current scenario. Specify scenario by name or ID or as a scenario object. This will not delete the specified scenario - it will only remove it from the list of additional scenarios associated with the current scenario. Use the Scenarios collection "Delete" method to delete a scenario.")]
        HRESULT RemoveAdditional([in] VARIANT Scenario);
        [id(0x000000d9), helpstring("Promote (move up) an additional scenario in the list of scenarios associated with the current scenario. Specify the scenario to be added by name or ID or as a scenario object.")]
        HRESULT PromoteAdditional([in] VARIANT Scenario);
        [id(0x000000da), helpstring("Demote (move down) an additional scenario in the list of scenarios associated with the current scenario. Specify the scenario to be added by name or ID or as a scenario object.")]
        HRESULT DemoteAdditional([in] VARIANT Scenario);
        [id(0x000000db), propget, helpstring("For IBC only. The method used for Base Year Particulate Scaling (0=none, 1=van Donkelaar, 2 = Shaddick)")]
        HRESULT IBCPMScaling([out, retval] int* Value);
        [id(0x000000db), propput, helpstring("For IBC only. The method used for Base Year Particulate Scaling (0=none, 1=van Donkelaar, 2 = Shaddick)")]
        HRESULT IBCPMScaling([in] int Value);
        [id(0x000000dc), propget, helpstring("For IBC only.  The relative risk function to be used for health impacts (0=Burnett 2014, 1=Cohen 2017)")]
        HRESULT IBCRelRiskFunction([out, retval] int* Value);
        [id(0x000000dc), propput, helpstring("For IBC only.  The relative risk function to be used for health impacts (0=Burnett 2014, 1=Cohen 2017)")]
        HRESULT IBCRelRiskFunction([in] int Value);
    };

    [
      uuid(0B9EC32E-7273-40A9-A46A-964E687D3439),
      version(1.0),
      helpstring("LEAPScenario Object")
    ]
    coclass LEAPScenario {
        [default] interface ILEAPScenario;
    };

    [
      odl,
      uuid(48B282B9-46F0-45A9-A7CC-C6BFFAC63966),
      version(1.0),
      helpstring("Dispatch Interface for LEAPScenarios Object"),
      dual,
      oleautomation
    ]
    interface ILEAPScenarios : IDispatch {
        [id(0x000000c9), propget, helpstring("The number of scenarios in the collection.")]
        HRESULT Count([out, retval] long* Value);
        [id(0xfffffffc), propget, hidden]
        HRESULT _NewEnum([out, retval] IUnknown** Value);
        [id(00000000), propget, helpstring("Get a scenario object by name or abbreviation ("scenarioname"), by index (1..count) or ("IX:XXX"),  or by ID ("ID:XXX").  Default property. Returns error if scenario does not exist.  Use Exists first.  Default property.")]
        HRESULT Item(
                        [in] VARIANT Index, 
                        [out, retval] ILEAPScenario** Value);
        [id(0x000000ca), propput, helpstring("Gets or sets whether results will be shown for all scenarios in the Results View.")]
        HRESULT ResultsShown([in] VARIANT_BOOL rhs);
        [id(0x000000cb), helpstring("Adds a new scenario with a specified name and abbreviation, with expressions based on the existing scenario with ID ParentScenarioID.")]
        HRESULT Add(
                        [in] BSTR ScenarioName, 
                        [in] BSTR ScenarioAbbreviation, 
                        [in] int ParentScenarioID, 
                        [out, retval] ILEAPScenario** Result);
        [id(0x000000cc), helpstring("Deletes the scenario referenced either by name or ID and all associated data.")]
        HRESULT Delete([in] VARIANT NameOrID);
        [id(0x000000cd), propget, helpstring("The maximum ID of all scenarios in the collection.")]
        HRESULT MaxID([out, retval] int* Value);
        [id(0x000000ce), helpstring("Tests if the named scenario exists in the current area. Accepts scenario name or abbreviation.")]
        HRESULT Exists(
                        [in] BSTR Name, 
                        [out, retval] VARIANT_BOOL* Result);
        [id(0x000000cf), hidden]
        HRESULT Init([in] int ParentID);
    };

    [
      uuid(6208EEB9-0ED4-4337-B4C7-1A5DB6549413),
      version(1.0),
      helpstring("LEAPScenarios Object")
    ]
    coclass LEAPScenarios {
        [default] interface ILEAPScenarios;
    };

    [
      odl,
      uuid(068F3716-E7A0-4517-87A9-2FC26E366F4A),
      version(1.0),
      helpstring("Dispatch Interface for LEAPBranches Object"),
      dual,
      oleautomation
    ]
    interface ILEAPBranches : IDispatch {
        [id(0x000000c9), propget, helpstring("The number of LEAP branches in the collection.")]
        HRESULT Count([out, retval] long* Value);
        [id(0xfffffffc), propget, hidden]
        HRESULT _NewEnum([out, retval] IUnknown** Value);
        [id(00000000), propget, helpstring("Gets branch by name ("branch name"), by index (1..count) or ("IX:XXX"), or by ID ("ID:XXX").  Default property. Returns error if does not exist.  Use Exists first.")]
        HRESULT Item(
                        [in] VARIANT Index, 
                        [out, retval] ILEAPBranch** Value);
        [id(0x000000cc), hidden]
        HRESULT Init([in] int ParentBranchID);
        [id(0x000000ca), propget, helpstring("The maximum ID of all branches in the area.")]
        HRESULT MaxID([out, retval] int* Value);
        [id(0x000000cb), helpstring("Tests if the full branch path exists in the current area.")]
        HRESULT Exists(
                        [in] BSTR BranchPath, 
                        [out, retval] VARIANT_BOOL* Result);
        [id(0x000000cd), hidden]
        HRESULT InitMany([in] VARIANT Children);
    };

    [
      uuid(9F1F7D08-2E79-46A6-8BCB-58B3710C5B09),
      version(1.0),
      helpstring("LEAPBranches Object")
    ]
    coclass LEAPBranches {
        [default] interface ILEAPBranches;
    };

    [
      odl,
      uuid(807592CD-BE50-4084-B399-82593A98F60A),
      version(1.0),
      helpstring("Dispatch Interface for LEAPBranch Object"),
      dual,
      oleautomation
    ]
    interface ILEAPBranch : IDispatch {
        [id(0x000000c9), hidden]
        HRESULT Init([in] int BranchID);
        [id(0x000000ca), propget, helpstring("Gets collection of the child branches under the current branch.")]
        HRESULT Children([out, retval] ILEAPBranches** Value);
        [id(0x000000cb), propget, helpstring("Get the collection of all variables belonging to this branch for the current globally selected region and scenario.")]
        HRESULT Variables([out, retval] ILEAPVariables** Value);
        [id(0x000000cd), propget, helpstring("Returns the full path of the current branch.")]
        HRESULT FullName([out, retval] BSTR* Value);
        [id(0x000000ce), propget, helpstring("Returns the depth of the the current branch in the tree. An integer value with the top level branch being level zero.")]
        HRESULT Level([out, retval] int* Value);
        [id(0x000000cc), propget, helpstring("Returns an integer value indicating the type of branch.  1=DemandCategoryBranchType, 2=TransformationModuleBranchType, 3=TransformationProcessBranchType, 4=DemandTechnologyBranchType, 5=TransformationProcessCategoryType, 6=TransformationOutputCategoryType, 7=TransformationOutputBranchType, 9=KeyAssumptionCategoryType, 10=KeyAssumptionBranchType, 11=ResourceRootType, 12=PrimaryBranchCategoryType, 13=SecondaryBranchCategoryType, 15=ResourceBranchType, 16=ResourceDisagType, 18=StatDiffRootType, 19=StockChangeRootType, 20=StatDiffPrimaryCategoryType, 21= StatDiffSecondaryCategoryType, 22=StockChangePrimaryCategoryType, 23=StockChangeSecondaryCategoryType, 24=StatDiffBranchType, 25=  StockChangeBranchType, 26=NonEnergyCategoryType, 27=NonEnergyBranchType, 30=AuxCategoryType, 31=AuxBranchType, 32=FeedstockCategoryType, 33= FeedstockBranchType, 34=DMDPollutionBranchType, 35=TransformationPollutionBranchType, 36=DemandFuelBranchType, 37=IndicatorCategoryType, 38=IndicatorBranchType, 39=EmissionConstraintBranchType")]
        HRESULT BranchType([out, retval] int* Value);
        [id(0x000000cf), propget, helpstring("Returns a label indicating the type of branch. Examples include: "Demand Category", "Demand Technology", "Transformation Process", "Transformation Module", "Key Assumption", "Non Energy", "Indicator" , "Resource"")]
        HRESULT BranchTypeName([out, retval] BSTR* Value);
        [id(0x000000d0), propget, helpstring("Returns a fuel object if a fuel is associated with the branch.  Otherwise returns nil.")]
        HRESULT Fuel([out, retval] ILEAPFuel** Value);
        [id(0x000000d1), propget, helpstring("The unique ID of the branch.  The ID is not displayed in the interface but may be useful when automating LEAP (Synonym for BranchID).")]
        HRESULT ID([out, retval] int* Value);
        [id(0x000000d2), propget, helpstring("The unique ID of the parent of the current branch.  Equivalent to Branch.Parent.ID. Deprecated.")]
        HRESULT ParentID(
                        [in, optional, defaultvalue(1)] int Levels, 
                        [out, retval] int* Value);
        [id(0x000000d3), propget, helpstring("Returns the branch above the current branch.  Note the top level branch has a nil parent")]
        HRESULT Parent(
                        [in, optional, defaultvalue(1)] int Levels, 
                        [out, retval] ILEAPBranch** Value);
        [id(0x000000d4), propget, helpstring("Gets or sets the visibility of the current branch for the specified region.  Branch visibility is relevant only for multi-region data sets.  When setting to true, the branch and all branches below and above it will also be made visible.")]
        HRESULT Visible(
                        [in] VARIANT RegionNameorID, 
                        [out, retval] VARIANT_BOOL* Value);
        [id(0x000000d4), propput, helpstring("Gets or sets the visibility of the current branch for the specified region.  Branch visibility is relevant only for multi-region data sets.  When setting to true, the branch and all branches below and above it will also be made visible.")]
        HRESULT Visible(
                        [in] VARIANT RegionNameorID, 
                        [in] VARIANT_BOOL Value);
        [id(0x000000d5), propget, helpstring("Gets the specified variable object.")]
        HRESULT Variable(
                        [in, defaultvalue("")] BSTR VariableName, 
                        [out, retval] ILEAPVariable** Value);
        [id(0x000000d6), propget, helpstring("Gets or sets if the branch is the active branch in the LEAP tree.")]
        HRESULT Active([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d6), propput, helpstring("Gets or sets if the branch is the active branch in the LEAP tree.")]
        HRESULT Active([in] VARIANT_BOOL Value);
        [id(0x000000d7), propget, helpstring("Returns the branch order. of the branch within the group of immediately neighboring branches. Use MoveUp and Move down to reorder branches.")]
        HRESULT Order([out, retval] long* Value);
        [id(0x000000d8), helpstring("Moves a branch up relative to its immediate neigbors in the tree (decrements its order).  If branch is the first branch then order is not changed.")]
        HRESULT MoveUp();
        [id(0x000000d9), helpstring("Moves a branch down relative to its immediate neighbors in the tree (increments its order).  If branch is the last branch the order is not changed.")]
        HRESULT MoveDown();
        [id(0x000000da), helpstring("Deletes the referenced branch.")]
        HRESULT Delete();
        [id(0x000000db), propget, helpstring("The unique ID of the branch.  The Branch ID is not displayed in the interface but may be useful when automating LEAP  (Synonym for ID).")]
        HRESULT BranchID([out, retval] int* Value);
        [id(0x000000dc), propget, helpstring("For Demand branches, returns the demand methodology as an integer value. Otherwise returns zero.  Demand methods are as follows (Annual Activity Level=0, Stock Turnover=1, Transport Stock Turnover=2, Total Annual Energy=3, Time Sliced Activity Level =4, Total Energy Time-Sliced=5, Power-Sliced Activity Level=6, Total Power Time-Sliced= 7)")]
        HRESULT DemandMethod([out, retval] int* Value);
        [id(0x000000dd), propget, helpstring("Returns true if the branch is an end-use intensity demand branch.")]
        HRESULT IsEndUseIntensity([out, retval] VARIANT_BOOL* Value);
        [id(0x000000de), propget, helpstring("Returns true if the branch is a useful energy demand  branch. (Read-Only)")]
        HRESULT IsUseful([out, retval] VARIANT_BOOL* Value);
        [id(0x000000df), propget, helpstring("Returns true if the branch is a useful energy intensity branch and is set to use final energy intensities in Current Accounts.  (Read-Only)")]
        HRESULT IsFinalIntensityInCurrentAccounts([out, retval] VARIANT_BOOL* Value);
        [id(0x000000e0), propget, helpstring("Returns true if the specified variable exists for this branch.")]
        HRESULT VariableExists(
                        [in] BSTR VariableName, 
                        [out, retval] VARIANT_BOOL* Value);
        [id(0x000000e1), propget, helpstring("Gets or sets text-based notes associated with the branch.  Plain text only.  No formatting can be added using the API.")]
        HRESULT Notes([out, retval] BSTR* Value);
        [id(0x000000e1), propput, helpstring("Gets or sets text-based notes associated with the branch.  Plain text only.  No formatting can be added using the API.")]
        HRESULT Notes([in] BSTR Value);
        [id(0x000000e2), propget, helpstring("Returns a TED technology object containing the best set of IPCC Tier 1 emission factors for the branch.  If no such technology is available, a nil object is returned.")]
        HRESULT IPCCTEDTechnology([out, retval] ITEDTechnology** Value);
        [id(0x000000e3), propget, hidden, helpstring("Returns  the ID of a TED technology containing the best set of IPCC Tier 1 emission factors for the branch.")]
        HRESULT IPCCTEDTechnologyID([out, retval] int* Value);
        [id(0x000000e4), propget, helpstring("Integer indicating the image for the tree branch: folder=0/3, technology=1, Key assumption=2, fuel=4, green folder=5, stock change=6, effect (cloud)=7, transport (wheel)=8, variable=10, indicator=11")]
        HRESULT Image([out, retval] int* Value);
        [id(0x000000e5), propget, helpstring("Gets or sets the expanded status of the branch.")]
        HRESULT Expanded([out, retval] VARIANT_BOOL* Value);
        [id(0x000000e5), propput, helpstring("Gets or sets the expanded status of the branch.")]
        HRESULT Expanded([in] VARIANT_BOOL Value);
        [id(0x000000e6), helpstring("Expands the branch, optionally recursively expanding all lower branches if optional "recurse" parameter is set to true.")]
        HRESULT Expand([in] VARIANT_BOOL Recurse);
        [id(0x000000e7), propget, helpstring("Gets or sets the name of the branch.")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(0x000000e7), propput, helpstring("Gets or sets the name of the branch.")]
        HRESULT Name([in] BSTR Value);
        [id(0x000000e8), propget, helpstring("The index number of the  branch from 1..LEAP.Branches.Count.")]
        HRESULT Index([out, retval] int* Value);
        [id(0x000000e9), propget, helpstring("Gets the collection of tags belonging to the branch. Use the Count property to find the number of tags.")]
        HRESULT Tags([out, retval] ILEAPTags** Value);
        [id(0x000000ea), propget, helpstring("Gets or sets whether the branch is locked.")]
        HRESULT Locked([out, retval] VARIANT_BOOL* Value);
        [id(0x000000ea), propput, helpstring("Gets or sets whether the branch is locked.")]
        HRESULT Locked([in] VARIANT_BOOL Value);
        [id(0x000000eb), propget, helpstring("Returns the FuelID associated with the branch (if any).  If none, returns -1.")]
        HRESULT FuelID([out, retval] int* Value);
        [id(0x000000ec), propget, helpstring("Returns the EffectID associated with the branch (if any).  If none, returns -1.")]
        HRESULT EffectID([out, retval] int* Value);
        [id(0x000000ed), propget, helpstring("Returns true if the branch is a Transformation storage process. (Read-Only)")]
        HRESULT IsStorage([out, retval] VARIANT_BOOL* Value);
        [id(0x000000ee), propget, helpstring("Adds branch to endogenous capacity addition list for current region and scenario (only works for Transformation processes and in simulation scenarios).")]
        HRESULT AddToEndogenousCapacity([out, retval] VARIANT_BOOL* Value);
        [id(0x000000ef), propget, helpstring("Removes branch from endogenous capacity addition list for current region and scenario (only works for Transformation processes and in simulation scenarios).")]
        HRESULT RemoveFromEndogenousCapacity([out, retval] VARIANT_BOOL* Value);
        [id(0x000000f0), propget, hidden, helpstring("Adds a tag to a branch: the tag parameter can be a tag object or the name of a new or existing tag.")]
        HRESULT AddTag(
                        [in] VARIANT Tag, 
                        [in] VARIANT_BOOL AddToChildren, 
                        [out, retval] ILEAPTag* Value);
        [id(0x000000f1), propget, hidden, helpstring("Removes a tag at a branch.  Returns true if successful.  Tag parameter can be either a Tag object or the name of an existing tag.")]
        HRESULT RemoveTag(
                        [in] VARIANT Tag, 
                        [in] VARIANT_BOOL RemoveFromChildren, 
                        [out, retval] VARIANT_BOOL* Value);
    };

    [
      uuid(832487C5-56ED-49FD-8425-9F00BB69155F),
      version(1.0),
      helpstring("LEAPBranch Object")
    ]
    coclass LEAPBranch {
        [default] interface ILEAPBranch;
    };

    [
      odl,
      uuid(01D8DE23-3B0B-431C-BA61-2B57C26CF077),
      version(1.0),
      helpstring("Dispatch Interface for LEAPVariables Object"),
      dual,
      oleautomation
    ]
    interface ILEAPVariables : IDispatch {
        [id(0x000000c9), propget, helpstring("The number of LEAP variables in the collection.")]
        HRESULT Count([out, retval] long* Value);
        [id(0xfffffffc), propget, hidden]
        HRESULT _NewEnum([out, retval] IUnknown** Value);
        [id(0x000000cc), hidden]
        HRESULT Init([in] int BranchID);
        [id(00000000), propget, helpstring("Get variable by name, index (1..count) or ID (syntax ID:XXX). Default property.")]
        HRESULT Item(
                        [in] VARIANT Index, 
                        [out, retval] LEAPVariable** Value);
    };

    [
      uuid(032F589E-1E60-4D91-BF20-37B802EF9CAC),
      version(1.0),
      helpstring("LEAPVariable Object")
    ]
    coclass LEAPVariables {
        [default] interface ILEAPVariables;
    };

    [
      odl,
      uuid(9B03F9C5-5B2D-4E9D-A43E-3D08B1D6AF6D),
      version(1.0),
      helpstring("Dispatch Interface for LEAPAreas Object"),
      dual,
      oleautomation
    ]
    interface ILEAPAreas : IDispatch {
        [id(0x000000c9), propget, helpstring("The number of LEAP areas.")]
        HRESULT Count([out, retval] long* Value);
        [id(0xfffffffc), propget, hidden]
        HRESULT _NewEnum([out, retval] IUnknown** Value);
        [id(00000000), propget, helpstring("Get area by name ("area name") or by index (1..count).  Default property.")]
        HRESULT Item(
                        [in] VARIANT Index, 
                        [out, retval] ILEAPArea** Value);
        [id(0x000000ca), helpstring("Creates and returns a new named area.  Optionally copied from another area.  If CopyFromArea is blank the new area is created from default data.")]
        HRESULT Add(
                        [in] BSTR AreaName, 
                        [in] BSTR CopyFromArea, 
                        [out, retval] ILEAPArea** Result);
        [id(0x000000cb), helpstring("Deletes the named area.")]
        HRESULT Delete([in] BSTR AreaName);
        [id(0x000000cc), helpstring("Tests if the area exists on your PC.")]
        HRESULT Exists(
                        [in] BSTR AreaName, 
                        [out, retval] VARIANT_BOOL* Result);
    };

    [
      uuid(4729FD9E-A884-452C-8AC0-9DD64E587BF6),
      version(1.0),
      helpstring("LEAPAreas Object")
    ]
    coclass LEAPAreas {
        [default] interface ILEAPAreas;
    };

    [
      odl,
      uuid(EAE47235-8EBD-4332-990C-DD89512CD693),
      version(1.0),
      helpstring("Dispatch Interface for LEAPArea Object"),
      dual,
      oleautomation
    ]
    interface ILEAPArea : IDispatch {
        [id(00000000), propget, helpstring("Gets the name of an area. Default property.")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(00000000), propput, helpstring("Gets the name of an area. Default property.")]
        HRESULT Name([in] BSTR Value);
        [id(0x000000c9), helpstring("Opens an area (Makes it the active area).")]
        HRESULT Open();
        [id(0x000000cb), helpstring("Saves the area. Only applicable if the area is the active area.")]
        HRESULT Save();
        [id(0x000000cc), propget, helpstring("Returns the folder for the area.")]
        HRESULT Directory([out, retval] BSTR* Value);
        [id(0x000000ca), hidden]
        HRESULT Init([in] BSTR AreaName);
        [id(0x000000cd), propget, helpstring("Returns true if the area is active or opens the area.")]
        HRESULT Active([out, retval] VARIANT_BOOL* Value);
        [id(0x000000cd), propput, helpstring("Returns true if the area is active or opens the area.")]
        HRESULT Active([in] VARIANT_BOOL Value);
        [id(0x000000ce), helpstring("Copies the fuels database from another area.  Use with caution: copying a different set of fuels may affect your Demand and Transformation data.")]
        HRESULT CopyFuelsFrom([in] BSTR AreaName);
        [id(0x000000d0), propget, helpstring("Indicates if area is currently archived in .zip or .leap format.")]
        HRESULT Archived([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d1), propget, helpstring("Indicates if area is in pre v2011 (BDE) file format.")]
        HRESULT Pre2011([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d2), propget, helpstring("Returns whether the area is marked")]
        HRESULT ReadOnly([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d3), propget, helpstring("Backs up an area to a specified folder and optionall gives it a new filename. BackupMode=0 (None),1 (All)  or 2 (Named versions).  Returns true if successful.")]
        HRESULT Backup(
                        [in] BSTR BackupFolder, 
                        [in, defaultvalue(3)] int BackupMode, 
                        [in, defaultvalue("")] BSTR ToFilename, 
                        [out, retval] VARIANT_BOOL* Value);
        [id(0x000000cf), propget, helpstring("Gets the country name of the area (if any) as specified in the Settings: Scope screen. Default property.")]
        HRESULT CountryName([out, retval] BSTR* Value);
        [id(0x000000d4), propget, helpstring("Gets the two letter country code of the area (if any) based on country specified in the Settings: Scope screen. Default property.")]
        HRESULT CountryCode2([out, retval] BSTR* Value);
        [id(0x000000d5), propget, helpstring("Gets the three letter country code of the area (if any) based on country specified in the Settings: Scope screen. Default property.")]
        HRESULT CountryCode3([out, retval] BSTR* Value);
    };

    [
      uuid(25B8F2F0-5B40-4E19-9151-8ACADE92CCBD),
      version(1.0),
      helpstring("LEAPArea Object")
    ]
    coclass LEAPArea {
        [default] interface ILEAPArea;
    };

    [
      uuid(68B39A8E-DA0D-400C-8E87-9017839D56A0),
      version(1.0),
      helpstring("Dispatch interface for LEAPApplicationEvents Object")
    ]
    dispinterface ILEAPApplicationEvents {
        properties:
        methods:
            [id(0x000000c9)]
            HRESULT OnShutdown();
    };

    [
      odl,
      uuid(C0BB52C6-0653-4B20-94C0-AB15B2CCF830),
      version(1.0),
      helpstring("Dispatch Interface for ILEAPVariableObject"),
      dual,
      oleautomation
    ]
    interface ILEAPVariable : IDispatch {
        [id(0x000000c9), hidden]
        HRESULT Init(
                        [in] int BranchID, 
                        [in] int VariableID);
        [id(0x000000cc), propget, hidden, helpstring("No longer available. Instead use Value property for all variables.")]
        HRESULT DataValue(
                        [in, optional, defaultvalue(0)] int Year, 
                        [out, retval] double* Value);
        [id(00000000), propget, helpstring("Sets or gets the data expression for the variable for the active region and scenario.")]
        HRESULT Expression([out, retval] VARIANT* Value);
        [id(00000000), propput, helpstring("Sets or gets the data expression for the variable for the active region and scenario.")]
        HRESULT Expression([in] VARIANT Value);
        [id(0x000000cb), propget, helpstring("Returns true if the variable expression is inherited from another region or scenario, and false if the expression was explicitly entered for this region and scenario.  Generates an error for a result variable.")]
        HRESULT InheritedExpression([out, retval] VARIANT_BOOL* Value);
        [id(0x000000cd), propget, helpstring("Returns true if the variable is a data variable, and false if variable is a result variable.")]
        HRESULT IsData([out, retval] VARIANT_BOOL* Value);
        [id(0x000000ce), propget, hidden, helpstring("No longer available. Instead use Value property for all variables.")]
        HRESULT ResultValue(
                        [in, optional, defaultvalue(0)] int Year, 
                        [in, optional, defaultvalue("")] BSTR UnitName, 
                        [out, retval] double* Value);
        [id(0x000000cf), propget, helpstring("The unique ID of the variable.  The ID is not displayed in the interface but may be useful when automating LEAP.")]
        HRESULT ID([out, retval] int* Value);
        [id(0x000000d0), propget, helpstring("Gets a string containing the scale and units of the data value.")]
        HRESULT DataUnitText([out, retval] BSTR* Value);
        [id(0x000000d1), propget, helpstring("Returns the default unit for the results returned by the ResultValue property.")]
        HRESULT DefaultResultUnit([out, retval] ILEAPUnit** Value);
        [id(0x000000d2), propget, helpstring("Sets or gets a data expression for the current variable for the specified region and scenario.")]
        HRESULT ExpressionRS(
                        [in] VARIANT Region, 
                        [in] VARIANT Scenario, 
                        [out, retval] VARIANT* Value);
        [id(0x000000d2), propput, helpstring("Sets or gets a data expression for the current variable for the specified region and scenario.")]
        HRESULT ExpressionRS(
                        [in] VARIANT Region, 
                        [in] VARIANT Scenario, 
                        [in] VARIANT Value);
        [id(0x000000d3), propget, helpstring("Gets or sets the unit ID associated with the data expression.")]
        HRESULT DataUnitID([out, retval] long* Value);
        [id(0x000000d3), propput, helpstring("Gets or sets the unit ID associated with the data expression.")]
        HRESULT DataUnitID([in] long Value);
        [id(0x000000d4), propget, helpstring("Using the scale ID, gets or sets the scaling factor associated with the data expression.")]
        HRESULT Scale([out, retval] long* Value);
        [id(0x000000d4), propput, helpstring("Using the scale ID, gets or sets the scaling factor associated with the data expression.")]
        HRESULT Scale([in] long Value);
        [id(0x000000d5), propget, helpstring("Gets or sets the unit associated with the data expression.")]
        HRESULT DataUnit([out, retval] ILEAPUnit** Value);
        [id(0x000000d5), propput, helpstring("Gets or sets the unit associated with the data expression.")]
        HRESULT DataUnit([in] ILEAPUnit* Value);
        [id(0x000000d6), propget, helpstring("Gets the name of the variable. Default property.")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(0x000000d6), propput, helpstring("Gets the name of the variable. Default property.")]
        HRESULT Name([in] BSTR Value);
        [id(0x000000ca), propget, helpstring("Gets the value of a data or result variable in the specified year for the active scenario and region.")]
        HRESULT Value(
                        [in, defaultvalue(0)] int Year, 
                        [in, optional, defaultvalue("")] BSTR UnitName, 
                        [in, optional, defaultvalue("")] BSTR Filter, 
                        [out, retval] double* Value);
        [id(0x000000d7), propget, helpstring("Gets the ID of the branch at which the variable is located.")]
        HRESULT BranchID([out, retval] int* Value);
        [id(0x000000d8), propget, helpstring("Gets the name of the branch at which the variable is located.")]
        HRESULT BranchName([out, retval] BSTR* Value);
        [id(0x000000d9), propget, helpstring("Gets the branch at which the variable is located.")]
        HRESULT Branch([out, retval] ILEAPBranch** Value);
        [id(0x000000da), propget, helpstring("Gets the full combined branch/variable name in the format BranchName:VariableName.")]
        HRESULT BranchVariableName([out, retval] BSTR* Value);
        [id(0x000000db), propget, helpstring("Gets the value of a data or result variable in the specified region, scenario and year.")]
        HRESULT ValueRS(
                        [in] VARIANT Region, 
                        [in] VARIANT Scenario, 
                        [in, optional, defaultvalue(0)] int Year, 
                        [in, optional, defaultvalue("")] BSTR UnitName, 
                        [in, optional, defaultvalue("")] BSTR Filter, 
                        [out, retval] double* Value);
        [id(0x000000dc), propget, helpstring("Gets the value of a data or result variable in the specified region and year for the active scenario.")]
        HRESULT ValueR(
                        [in] VARIANT Region, 
                        [in, optional, defaultvalue(0)] int Year, 
                        [in, optional, defaultvalue("")] BSTR UnitName, 
                        [in, optional, defaultvalue("")] BSTR Filter, 
                        [out, retval] double* Value);
    };

    [
      uuid(65DF273A-5794-47BB-90BD-162E6D8973C6),
      version(1.0),
      helpstring("LEAPVariable Object")
    ]
    coclass LEAPVariable {
        [default] interface ILEAPVariable;
    };

    [
      odl,
      uuid(2B316D8D-A2B7-43B4-BCE8-A365A11650B4),
      version(1.0),
      helpstring("Dispatch interface for LEAPRegion Object"),
      dual,
      oleautomation
    ]
    interface ILEAPRegion : IDispatch {
        [id(0x000000ca), propget, helpstring("The unique ID of the region.  The ID is not displayed in the interface but may be useful when automating LEAP.")]
        HRESULT ID([out, retval] int* Value);
        [id(0x000000cb), hidden]
        HRESULT Init([in] int RegionID);
        [id(00000000), propget, helpstring("Gets or sets the name of the region. Default property.")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(00000000), propput, helpstring("Gets or sets the name of the region. Default property.")]
        HRESULT Name([in] BSTR Value);
        [id(0x000000cc), propget, helpstring("Obsolete. Use Region.Group(Index).Name.")]
        HRESULT Grouping([out, retval] BSTR* Value);
        [id(0x000000cd), propget, helpstring("Gets or sets whether results for the region will be calculated and displayed in Results view.")]
        HRESULT ResultsShown([out, retval] VARIANT_BOOL* Value);
        [id(0x000000cd), propput, helpstring("Gets or sets whether results for the region will be calculated and displayed in Results view.")]
        HRESULT ResultsShown([in] VARIANT_BOOL Value);
        [id(0x000000ce), propget, helpstring("Gets or sets the active region.")]
        HRESULT Active([out, retval] VARIANT_BOOL* Value);
        [id(0x000000ce), propput, helpstring("Gets or sets the active region.")]
        HRESULT Active([in] VARIANT_BOOL Value);
        [id(0x000000cf), propget, helpstring("Gets or sets a region from which the current region will inherit default expressions.")]
        HRESULT InheritsFromRegion([out, retval] ILEAPRegion** Value);
        [id(0x000000cf), propput, helpstring("Gets or sets a region from which the current region will inherit default expressions.")]
        HRESULT InheritsFromRegion([in] ILEAPRegion* Value);
        [id(0x000000c9), propget, hidden, helpstring("An integer tag for use by users.")]
        HRESULT Tag([out, retval] int* Value);
        [id(0x000000c9), propput, hidden, helpstring("An integer tag for use by users.")]
        HRESULT Tag([in] int Value);
        [id(0x000000d0), propget, helpstring("One of three floating point variables for use by the user.")]
        HRESULT User1([out, retval] double* Value);
        [id(0x000000d0), propput, helpstring("One of three floating point variables for use by the user.")]
        HRESULT User1([in] double Value);
        [id(0x000000d1), propget, helpstring("One of three floating point variables for use by the user.")]
        HRESULT User2([out, retval] double* Value);
        [id(0x000000d1), propput, helpstring("One of three floating point variables for use by the user.")]
        HRESULT User2([in] double Value);
        [id(0x000000d2), propget, helpstring("One of three floating point variables for use by the user.")]
        HRESULT User3([out, retval] double* Value);
        [id(0x000000d2), propput, helpstring("One of three floating point variables for use by the user.")]
        HRESULT User3([in] double Value);
        [id(0x000000d3), propget, helpstring("The index number of the region from 1..LEAP.Regions.Count.")]
        HRESULT Index([out, retval] int* Value);
        [id(0x000000d4), propget, helpstring("Gets or set one of the region groupings (balance categories) associated with the region.  Returns a LEAPRegionlGroup object.")]
        HRESULT Group(
                        [in] int Index, 
                        [out, retval] LEAPRegionGroup** Value);
        [id(0x000000d4), propput, helpstring("Gets or set one of the region groupings (balance categories) associated with the region.  Returns a LEAPRegionlGroup object.")]
        HRESULT Group(
                        [in] int Index, 
                        [in] LEAPRegionGroup* Value);
        [id(0x000000d5), propget, helpstring("Gets or sets the name of the abbreviation for the region. Use 2 letter abbreviations to map your regions to LEAP's pre-defined countries.")]
        HRESULT Abbreviation([out, retval] BSTR* Value);
        [id(0x000000d5), propput, helpstring("Gets or sets the name of the abbreviation for the region. Use 2 letter abbreviations to map your regions to LEAP's pre-defined countries.")]
        HRESULT Abbreviation([in] BSTR Value);
        [id(0x000000d6), propget, helpstring("Gets if region is a valid country for use with IBC's PM2.5 impact calculations. Read Only. Based on two letter country code abbreviation.")]
        HRESULT IBC_PM25([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d7), propget, helpstring("Gets if region is a valid country for use with IBC's ozone/health impact calculations. Read Only. Based on two letter country code abbreviation.")]
        HRESULT IBC_O3Health([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d8), propget, helpstring("Gets if region is a valid country for use with IBC's ozone/vegetation impact calculations. Read Only. Based on two letter country code abbreviation.")]
        HRESULT IBC_O3Veg([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d9), propget]
        HRESULT Latitude([out, retval] double* Value);
        [id(0x000000da), propget, helpstring("Gets the longitude of the region (if it is one of LEAP's pre-defined countries). Read Only. Based on two letter country code abbreviation.")]
        HRESULT Longitude([out, retval] double* Value);
        [id(0x000000db), propget, helpstring("Gets the default mapping zoom factor for the region (if it is one of LEAP's pre-defined countries). Read Only. Based on two letter country code abbreviation.")]
        HRESULT Zoom([out, retval] int* Value);
        [id(0x000000dc), propget, helpstring("Gets if the region is currently a low or middle income country (if it is one of LEAP's pre-defined countries). Read Only. Based on two letter country code abbreviation.")]
        HRESULT IsDeveloping([out, retval] VARIANT_BOOL* Value);
        [id(0x000000dd), propget, helpstring("Gets LEAP's internal country ID for the region (if it is one of LEAP's pre-defined countries). Read Only. Based on two letter country code abbreviation.")]
        HRESULT CountryID([out, retval] int* Value);
        [id(0x000000de), propget, helpstring("Gets 3-digit numeric country code for the region (if it is one of LEAP's pre-defined countries). Read Only. Based on two letter country code abbreviation.")]
        HRESULT CountryCode([out, retval] int* Value);
        [id(0x000000df), propget, helpstring("Gets or sets one of the region grouping IDs associated with the region.  ")]
        HRESULT GroupID(
                        [in] int Index, 
                        [out, retval] int* Value);
        [id(0x000000df), propput, helpstring("Gets or sets one of the region grouping IDs associated with the region.  ")]
        HRESULT GroupID(
                        [in] int Index, 
                        [in] int Value);
    };

    [
      uuid(81232563-51A5-4528-9718-41949CE4846F),
      version(1.0),
      helpstring("LEAPRegion Object")
    ]
    coclass LEAPRegion {
        [default] interface ILEAPRegion;
    };

    [
      odl,
      uuid(BB131E03-5AC8-4D66-B087-4F05F267CB9E),
      version(1.0),
      helpstring("Dispatch interface for the LEAPRegions Object"),
      dual,
      oleautomation
    ]
    interface ILEAPRegions : IDispatch {
        [id(0x000000c9), propget, helpstring("The number of regions in the collection.")]
        HRESULT Count([out, retval] long* Value);
        [id(0xfffffffc), propget, hidden]
        HRESULT _NewEnum([out, retval] IUnknown** Value);
        [id(00000000), propget, helpstring("Get a region object by name or abbreviation ("region name"), by index (1..count) or ("IX:XXX"),  or by ID ("ID:XXX").  Default property. Returns error if effect does not exist.  Use Exists first.")]
        HRESULT Item(
                        [in] VARIANT Index, 
                        [out, retval] ILEAPRegion** Value);
        [id(0x000000ca), helpstring("Adds a new named region.")]
        HRESULT Add(
                        [in] BSTR RegionName, 
                        [out, retval] ILEAPRegion** Result);
        [id(0x000000cb), helpstring("Deletes the region, referenced by name or ID.")]
        HRESULT Delete([in] VARIANT NameOrID);
        [id(0x000000cc), propget]
        HRESULT MaxID([out, retval] int* Value);
        [id(0x000000cd), helpstring("Tests if the named region exists in the current area. Accepts region name or abbreviation.")]
        HRESULT Exists(
                        [in] BSTR Name, 
                        [out, retval] VARIANT_BOOL* Result);
    };

    [
      uuid(158BE334-5766-4D7B-A671-6FFEF086A531),
      version(1.0),
      helpstring("LEAPRegions Object")
    ]
    coclass LEAPRegions {
        [default] interface ILEAPRegions;
    };

    [
      odl,
      uuid(52136F96-4207-4DFD-8A63-90388BF85699),
      version(1.0),
      helpstring("Dispatch interface for LEAPFuel Object"),
      dual,
      oleautomation
    ]
    interface ILEAPFuel : IDispatch {
        [id(00000000), propget, helpstring("Gets or sets the name of the fuel. Default property.")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(00000000), propput, helpstring("Gets or sets the name of the fuel. Default property.")]
        HRESULT Name([in] BSTR Value);
        [id(0x000000c9), propget, helpstring("The unique ID of the fuel.  The ID is not displayed in the interface but may be useful when automating LEAP.")]
        HRESULT ID([out, retval] int* Value);
        [id(0x000000ca), hidden]
        HRESULT Init([in] int FuelID);
        [id(0x000000cb), propget, helpstring("Returns true if fuel is used in the area. Otherwise false.")]
        HRESULT UsedInArea([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d1), propget, helpstring("Returns the fuel state as text: solid, liquid, gas or energy.")]
        HRESULT State([out, retval] BSTR* Value);
        [id(0x000000d2), propget, hidden, helpstring("Obsolete.  Use Fuel.Group(Index).Name.")]
        HRESULT Grouping([out, retval] BSTR* Value);
        [id(0x000000d3), propget, helpstring("Returns the type of fuel (fossil, biomass or renewable resource secondary fuel, electricity).")]
        HRESULT Fueltype([out, retval] BSTR* Value);
        [id(0x000000d6), propget, helpstring("Returns the energy content of the fuel (energy units per physical unit): a string with the value and units appended.")]
        HRESULT EnergyContent([out, retval] BSTR* Value);
        [id(0x000000cc), propget, helpstring("Chemical composition of fuel.  Percentage ash by weight.")]
        HRESULT PercentAsh([out, retval] double* Value);
        [id(0x000000cc), propput, helpstring("Chemical composition of fuel.  Percentage ash by weight.")]
        HRESULT PercentAsh([in] double Value);
        [id(0x000000cd), propget, helpstring("Chemical composition of fuel.  Percentage carbon by weight.")]
        HRESULT PercentCarbon([out, retval] double* Value);
        [id(0x000000cd), propput, helpstring("Chemical composition of fuel.  Percentage carbon by weight.")]
        HRESULT PercentCarbon([in] double Value);
        [id(0x000000ce), propget, helpstring("Chemical composition of fuel.  Percentage sulfur by weight.")]
        HRESULT PercentSulfur([out, retval] double* Value);
        [id(0x000000ce), propput, helpstring("Chemical composition of fuel.  Percentage sulfur by weight.")]
        HRESULT PercentSulfur([in] double Value);
        [id(0x000000cf), propget, helpstring("Chemical composition of fuel.  Percentage nitrogen by weight.")]
        HRESULT PercentNitrogen([out, retval] double* Value);
        [id(0x000000cf), propput, helpstring("Chemical composition of fuel.  Percentage nitrogen by weight.")]
        HRESULT PercentNitrogen([in] double Value);
        [id(0x000000d0), propget, helpstring("Density of the fuel (kg/liter)")]
        HRESULT Density([out, retval] double* Value);
        [id(0x000000d0), propput, helpstring("Density of the fuel (kg/liter)")]
        HRESULT Density([in] double Value);
        [id(0x000000d4), propget, helpstring("Chemical composition of fuel.  Percentage lead by weight.")]
        HRESULT PercentLead([out, retval] double* Value);
        [id(0x000000d4), propput, helpstring("Chemical composition of fuel.  Percentage lead by weight.")]
        HRESULT PercentLead([in] double Value);
        [id(0x000000d5), propget, helpstring("Lower to higher heating value ratio.")]
        HRESULT LhvHhvRatio([out, retval] double* Value);
        [id(0x000000d5), propput, helpstring("Lower to higher heating value ratio.")]
        HRESULT LhvHhvRatio([in] double Value);
        [id(0x000000d7), propget, helpstring("Chemical composition of fuel.  Percentage moisture (water) by weight.")]
        HRESULT PercentMoisture([out, retval] double* Value);
        [id(0x000000d7), propput, helpstring("Chemical composition of fuel.  Percentage moisture (water) by weight.")]
        HRESULT PercentMoisture([in] double Value);
        [id(0x000000d8), propget, helpstring("Percentage of fuel oxidized during combustion by energy content.")]
        HRESULT PercentOxidized([out, retval] double* Value);
        [id(0x000000d8), propput, helpstring("Percentage of fuel oxidized during combustion by energy content.")]
        HRESULT PercentOxidized([in] double Value);
        [id(0x000000d9), propget, hidden, helpstring("An integer "tag" variable: for any user-defined data.")]
        HRESULT Tag([out, retval] int* Value);
        [id(0x000000d9), propput, hidden, helpstring("An integer "tag" variable: for any user-defined data.")]
        HRESULT Tag([in] int Value);
        [id(0x000000da), propget, helpstring("One of three floating point variables for use by the user.")]
        HRESULT User1([out, retval] double* Value);
        [id(0x000000da), propput, helpstring("One of three floating point variables for use by the user.")]
        HRESULT User1([in] double Value);
        [id(0x000000db), propget, helpstring("One of three floating point variables for use by the user.")]
        HRESULT User2([out, retval] double* Value);
        [id(0x000000db), propput, helpstring("One of three floating point variables for use by the user.")]
        HRESULT User2([in] double Value);
        [id(0x000000dc), propget, helpstring("One of three floating point variables for use by the user.")]
        HRESULT User3([out, retval] double* Value);
        [id(0x000000dc), propput, helpstring("One of three floating point variables for use by the user.")]
        HRESULT User3([in] double Value);
        [id(0x000000dd), propget, helpstring("The index number of the fuel from 1..LEAP.Fuels.Count.")]
        HRESULT Index([out, retval] int* Value);
        [id(0x000000de), propget, helpstring("Gets or set one of the fuel groupings (balance categories) associated with the fuel.  Returns a LEAPFuelGroup object.")]
        HRESULT Group(
                        [in] int Index, 
                        [out, retval] LEAPFuelGroup** Value);
        [id(0x000000de), propput, helpstring("Gets or set one of the fuel groupings (balance categories) associated with the fuel.  Returns a LEAPFuelGroup object.")]
        HRESULT Group(
                        [in] int Index, 
                        [in] LEAPFuelGroup* Value);
    };

    [
      uuid(EAF35231-F7AA-40E3-933C-5F526BF72BFC),
      version(1.0),
      helpstring("LEAPFuel Object")
    ]
    coclass LEAPFuel {
        [default] interface ILEAPFuel;
    };

    [
      odl,
      uuid(8FFFA641-C3DD-48F3-83EE-8B7360D55E0A),
      version(1.0),
      helpstring("Dispatch interface for LEAPFuels Object"),
      dual,
      oleautomation
    ]
    interface ILEAPFuels : IDispatch {
        [id(0x000000c9), propget, helpstring("The number of fuels in the collection.")]
        HRESULT Count([out, retval] long* Value);
        [id(0xfffffffc), propget, hidden]
        HRESULT _NewEnum([out, retval] IUnknown** Value);
        [id(00000000), propget, helpstring("Get a fuel object by name ("fuel name"), by index (1..count) or ("IX:XXX"),  by ID ("ID:XXX") or by branch ID ("BR:XXX"). Default property. Returns error if does not exist.  Use Exists first.")]
        HRESULT Item(
                        [in] VARIANT Index, 
                        [out, retval] ILEAPFuel** Value);
        [id(0x000000ca), helpstring("Adds a new named fuel, returning a Fuel object.  The fuel can be created as a copy of another fuel by specifying the name of that fuel in CopyFromFuelName. If blank, the fuel is created with default characteristics.  FuelState indicates the state of the new fuel (0, 1, 2, 3 indicate solid, liquid, gas and pure energy states).")]
        HRESULT Add(
                        [in] BSTR FuelName, 
                        [in] BSTR CopyFromFuelName, 
                        [in] int FuelState, 
                        [out, retval] ILEAPFuel** Result);
        [id(0x000000cb), helpstring("Deletes the fuel, referenced by name or ID.")]
        HRESULT Delete([in] VARIANT NameOrID);
        [id(0x000000cc), helpstring("Tests if the named fuel exists in the current area.")]
        HRESULT Exists(
                        [in] BSTR Name, 
                        [out, retval] VARIANT_BOOL* Result);
    };

    [
      uuid(7621E367-9A7A-4172-AB06-DED147B7684B),
      version(1.0),
      helpstring("LEAPFuels Object")
    ]
    coclass LEAPFuels {
        [default] interface ILEAPFuels;
    };

    [
      odl,
      uuid(12140C31-3B18-4BD3-AE4E-CA010B69C237),
      version(1.0),
      helpstring("Dispatch interface for Favorite Object"),
      dual,
      oleautomation
    ]
    interface ILEAPFavorite : IDispatch {
        [id(0x000000c9), hidden]
        HRESULT Init([in] int Index);
        [id(00000000), propget, helpstring("The name of the favorite chart or table: includes both the folder name (if it exists) and favorite name separated by a #. Default property.")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(00000000), propput, helpstring("The name of the favorite chart or table: includes both the folder name (if it exists) and favorite name separated by a #. Default property.")]
        HRESULT Name([in] BSTR Value);
        [id(0x000000ca), helpstring("Sets the favorite chart to be active.  Selects the chart in Results View.")]
        HRESULT Activate();
        [id(0x000000cb), propget, helpstring("The name of the favorite folder.  Will be blank if favorite is not placed in a folder.")]
        HRESULT FolderName([out, retval] BSTR* Value);
        [id(0x000000cc), propget, helpstring("The name of the favorite not including any folder.")]
        HRESULT FaveName([out, retval] BSTR* Value);
    };

    [
      uuid(0204CE75-418B-4A60-8698-9D3F082E3F17),
      version(1.0),
      helpstring("Favorite Object")
    ]
    coclass LEAPFavorite {
        [default] interface ILEAPFavorite;
    };

    [
      odl,
      uuid(7D119D89-D42F-42A9-95BA-6B85230BFC3E),
      version(1.0),
      helpstring("Dispatch interface for Favorites Object"),
      dual,
      oleautomation
    ]
    interface ILEAPFavorites : IDispatch {
        [id(0x000000c9), propget, helpstring("The number of favorites in the collection.")]
        HRESULT Count([out, retval] long* Value);
        [id(0xfffffffc), propget, hidden]
        HRESULT _NewEnum([out, retval] IUnknown** Value);
        [id(00000000), propget, helpstring("Get favorite by name ("favorite name") or by index (1..count).  Default property.")]
        HRESULT Item(
                        [in] VARIANT Index, 
                        [out, retval] ILEAPFavorite** Value);
        [id(0x000000ca), helpstring("Tests if the named favorite exists in the current area.")]
        HRESULT Exists(
                        [in] BSTR Name, 
                        [out, retval] VARIANT_BOOL* Result);
    };

    [
      uuid(ACE7FDEC-D6BA-4761-862E-7ACB42559EAA),
      version(1.0),
      helpstring("Favorites Object")
    ]
    coclass LEAPFavorites {
        [default] interface ILEAPFavorites;
    };

    [
      odl,
      uuid(4B4587B2-7C8B-483E-ADF0-8E219818F366),
      version(1.0),
      helpstring("Dispatch interface for LEAPUnit Object"),
      dual,
      oleautomation
    ]
    interface ILEAPUnit : IDispatch {
        [id(00000000), propget, helpstring("Gets or sets the unit name.")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(00000000), propput, helpstring("Gets or sets the unit name.")]
        HRESULT Name([in] BSTR Value);
        [id(0x000000ca), propget, helpstring("The unique ID of the unit. The ID is not displayed in the interface but may be useful when automating LEAP.")]
        HRESULT ID([out, retval] int* Value);
        [id(0x000000cb), hidden]
        HRESULT Init([in] int UnitID);
        [id(0x000000c9), propget, helpstring("Gets a string indicating the unit class (energy, power, mass, volume, area, length, currency, etc.).")]
        HRESULT UnitClass([out, retval] BSTR* Value);
        [id(0x000000cc), propget, helpstring("Gets the short abbreviation for the unit.")]
        HRESULT Abbreviation([out, retval] BSTR* Value);
        [id(0x000000cd), propget, helpstring("Gets a string showing the conversion factor from the current unit to the default unit in the classs.")]
        HRESULT ConversionFactor([out, retval] BSTR* Value);
        [id(0x000000ce), propget, helpstring("The index number of the unit from 1..LEAP.Units.Count.")]
        HRESULT Index([out, retval] int* Value);
    };

    [
      uuid(B34F6558-36C7-4D84-A447-5F2D1705A0D2),
      version(1.0),
      helpstring("LEAPUnit Object")
    ]
    coclass LEAPUnit {
        [default] interface ILEAPUnit;
    };

    [
      odl,
      uuid(FA9DFD90-1ED3-43B6-BC5E-2E861144E27F),
      version(1.0),
      helpstring("Dispatch interface for LEAPUnits Object"),
      dual,
      oleautomation
    ]
    interface ILEAPUnits : IDispatch {
        [id(0x000000c9), propget, helpstring("The number of units in the collection.")]
        HRESULT Count([out, retval] long* Value);
        [id(0xfffffffc), propget, hidden]
        HRESULT _NewEnum([out, retval] IUnknown** Value);
        [id(00000000), propget, helpstring("Get unit by name or abbreviation, by index (1..count) or ("IX:XXX") or by ID ("ID:XXX").  Default property. Returns error if does not exist. Use Exists first.")]
        HRESULT Item(
                        [in] VARIANT Index, 
                        [out, retval] ILEAPUnit** Value);
        [id(0x000000ca), propget, helpstring("The maximum ID of all units in the collection.")]
        HRESULT MaxID([out, retval] int* Value);
        [id(0x000000cb), helpstring("Tests if the named unit exists in the current collection. Accepts a string (the unit name to test for) as a parameter.")]
        HRESULT Exists(
                        [in] BSTR UnitName, 
                        [out, retval] VARIANT_BOOL* Result);
    };

    [
      uuid(0B0579C3-24FD-4FAF-AE6B-AEF4AC85EA94),
      version(1.0),
      helpstring("LEAPUnits Object")
    ]
    coclass LEAPUnits {
        [default] interface ILEAPUnits;
    };

    [
      odl,
      uuid(44691B14-AF57-4A9D-90EE-CD1185A45045),
      version(1.0),
      helpstring("Dispatch interface for LEAPVersion Object"),
      dual,
      oleautomation
    ]
    interface ILEAPVersion : IDispatch {
        [id(0x000000c9), propget, helpstring("Get the filename, including full path, of the version.")]
        HRESULT FileName([out, retval] BSTR* Value);
        [id(0x000000ca), propget, helpstring("Get or set the comment associated with the version. The comment can be blank.")]
        HRESULT Comment([out, retval] BSTR* Value);
        [id(0x000000ca), propput, helpstring("Get or set the comment associated with the version. The comment can be blank.")]
        HRESULT Comment([in] BSTR Value);
        [id(0x000000cb), propget, helpstring("Get the date and time of the version.")]
        HRESULT Date([out, retval] DATE* Value);
        [id(0x000000cc), propget, helpstring("Gets the full name (both date and comment) of the version.")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(0x000000cd), hidden]
        HRESULT Init(
                        [in] BSTR AreaName, 
                        [in] BSTR FileName);
        [id(0x000000ce), helpstring("Reverts an area to the version specified in the filename. Use with caution: when you revert to a version, it will overwrite everything in the area, so that the area will be just as it was when the version was originally saved.")]
        HRESULT Revert();
        [id(0x000000cf), propget]
        HRESULT ID([out, retval] int* Value);
        [id(0x000000cf), propput]
        HRESULT ID([in] int Value);
    };

    [
      uuid(739B6C06-D559-4E48-ABE0-C504383CD756),
      version(1.0),
      helpstring("LEAPVersion Object")
    ]
    coclass LEAPVersion {
        [default] interface ILEAPVersion;
    };

    [
      odl,
      uuid(495CCC86-4980-414E-9CEC-A43A56B86F0D),
      version(1.0),
      helpstring("Dispatch interface for LEAPVersions Object"),
      dual,
      oleautomation
    ]
    interface ILEAPVersions : IDispatch {
        [id(0x000000c9), propget, helpstring("The number of versions in the collection.")]
        HRESULT Count([out, retval] long* Value);
        [id(0xfffffffc), propget, hidden]
        HRESULT _NewEnum([out, retval] IUnknown** Value);
        [id(00000000), propget, helpstring("Get version by comment or by index (1..count). If more than one version has the same comment, then the latest version is chosen.  Default property.")]
        HRESULT Item(
                        [in] VARIANT Index, 
                        [out, retval] ILEAPVersion** Value);
        [id(0x000000ca), helpstring("Deletes a version from the set of saved version.  Specify by name or index number (1..n)  of the version onbject. ")]
        HRESULT Delete([in] VARIANT Version);
    };

    [
      uuid(25868B83-DD0C-440E-AE4D-138AC0D62BA5),
      version(1.0),
      helpstring("LEAPVersions Object")
    ]
    coclass LEAPVersions {
        [default] interface ILEAPVersions;
    };

    [
      odl,
      uuid(E1362EEB-236B-4647-A029-0C8DE17EFFF9),
      version(1.0),
      helpstring("Dispatch interface for LEAPView Object"),
      dual,
      oleautomation
    ]
    interface ILEAPView : IDispatch {
        [id(0x000000c9), propget, helpstring("Gets the name of the view. Default property.")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(0x000000ca), propget, helpstring("Gets or sets whether the view is active.")]
        HRESULT Active([out, retval] VARIANT_BOOL* Value);
        [id(0x000000ca), propput, helpstring("Gets or sets whether the view is active.")]
        HRESULT Active([in] VARIANT_BOOL Value);
        [id(0x000000cb), hidden]
        HRESULT Init([in] int Index);
        [id(0x000000cc), propget, helpstring("The index number of the view from 1..LEAP.Views.Count.")]
        HRESULT Index([out, retval] int* Value);
    };

    [
      uuid(F90564D9-B807-4B67-9F91-50234875263A),
      version(1.0),
      helpstring("View Object")
    ]
    coclass LEAPView {
        [default] interface ILEAPView;
    };

    [
      odl,
      uuid(330B119A-80D8-4BED-9DC2-549883974AB2),
      version(1.0),
      helpstring("Dispatch interface for Views Object"),
      dual,
      oleautomation
    ]
    interface ILEAPViews : IDispatch {
        [id(0x000000c9), propget, helpstring("The number of views in the collection.")]
        HRESULT Count([out, retval] long* Value);
        [id(0xfffffffc), propget, hidden]
        HRESULT _NewEnum([out, retval] IUnknown** Value);
        [id(00000000), propget, helpstring("Get view by name ("viewname") or by index (1..count). Default property.")]
        HRESULT Item(
                        [in] VARIANT Index, 
                        [out, retval] ILEAPView** Value);
    };

    [
      uuid(5198D10B-161D-42A1-AFC0-6C00C478E443),
      version(1.0),
      helpstring("Views Object")
    ]
    coclass LEAPViews {
        [default] interface ILEAPViews;
    };

    [
      uuid(09FFD39D-DA79-44FB-BDED-908D6B1BBB02),
      version(1.0),
      helpstring("LEAPApplication Object"),
      appobject
    ]
    coclass LEAPApplication {
        [default] interface ILEAPApplication;
        [default, source] dispinterface ILEAPApplicationEvents;
    };

    [
      odl,
      uuid(C3ECFEE5-505E-443C-BDDE-8710641ACA2D),
      version(1.0),
      helpstring("Dispatch interface for LEAPUserVariable Object"),
      dual,
      oleautomation
    ]
    interface ILEAPUserVariable : IDispatch {
        [id(0x000000ca), propget, helpstring("The unique ID of the user variable.  This is not displayed in the interface but may be useful when automating LEAP.")]
        HRESULT ID([out, retval] int* Value);
        [id(0x000000c9), hidden]
        HRESULT Init([in] int ID);
        [id(0x000000cb), propget, helpstring("The name of the User Variable. Default property.")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(0x000000cb), propput, helpstring("The name of the User Variable. Default property.")]
        HRESULT Name([in] BSTR Value);
        [id(0x000000cc), propget, helpstring("Gets or sets the scaling factor of the user variable.")]
        HRESULT Scale([out, retval] int* ScaleValue);
        [id(0x000000cc), propput, helpstring("Gets or sets the scaling factor of the user variable.")]
        HRESULT Scale([in] int ScaleValue);
        [id(0x000000ce), propget, helpstring("Gets or sets the type of branch where the user variable is visible. -2=All Branches,1=All Demand,2=AllTransformation,10=KeyAssumptions,101=DMD Categories,104=DMD Technologies,102=TRN Modules,103=TRN Processes,107=TRN Outputs,15=Resources,34=Energy Effects,24=Stat Diffs,25=Stock Changes,38=Indicators,27=Non-Energy Effects,26=Non-Energy Categories.")]
        HRESULT BranchType([out, retval] int* BranchType);
        [id(0x000000ce), propput, helpstring("Gets or sets the type of branch where the user variable is visible. -2=All Branches,1=All Demand,2=AllTransformation,10=KeyAssumptions,101=DMD Categories,104=DMD Technologies,102=TRN Modules,103=TRN Processes,107=TRN Outputs,15=Resources,34=Energy Effects,24=Stat Diffs,25=Stock Changes,38=Indicators,27=Non-Energy Effects,26=Non-Energy Categories.")]
        HRESULT BranchType([in] int BranchType);
        [id(0x000000cd), propget, helpstring("Gets or sets the unit (as simple text) used to measure the user variable. Note: the user variables do not reference unit objects.")]
        HRESULT UnitStr([out, retval] BSTR* Value);
        [id(0x000000cd), propput, helpstring("Gets or sets the unit (as simple text) used to measure the user variable. Note: the user variables do not reference unit objects.")]
        HRESULT UnitStr([in] BSTR Value);
        [id(0x000000cf), propget, helpstring("The index number of the user variable from 1..LEAP.UserVariables.Count.")]
        HRESULT Index([out, retval] int* Value);
        [id(0x000000d0), propget, helpstring("Gets or set the notes associated with a user variable.")]
        HRESULT Notes([out, retval] BSTR* Value);
        [id(0x000000d0), propput, helpstring("Gets or set the notes associated with a user variable.")]
        HRESULT Notes([in] BSTR Value);
        [id(0x000000d1), propget, helpstring("Gets or sets the minimum value that can be associated with a user variable.")]
        HRESULT Min([out, retval] single* Value);
        [id(0x000000d1), propput, helpstring("Gets or sets the minimum value that can be associated with a user variable.")]
        HRESULT Min([in] single Value);
        [id(0x000000d2), propget, helpstring("Gets or sets the maximum value that can be associated with a user variable.")]
        HRESULT Max([out, retval] single* Value);
        [id(0x000000d2), propput, helpstring("Gets or sets the maximum value that can be associated with a user variable.")]
        HRESULT Max([in] single Value);
        [id(0x000000d3), propget, helpstring("Gets or sets if variable is visible in Current Accounts.")]
        HRESULT VisibleCurrentAccounts([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d3), propput, helpstring("Gets or sets if variable is visible in Current Accounts.")]
        HRESULT VisibleCurrentAccounts([in] VARIANT_BOOL Value);
        [id(0x000000d4), propget, helpstring("Gets or sets if variable is visible in all scenarios.")]
        HRESULT VisibleScenarios([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d4), propput, helpstring("Gets or sets if variable is visible in all scenarios.")]
        HRESULT VisibleScenarios([in] VARIANT_BOOL Value);
        [id(0x000000d5), propget, helpstring("Gets or sets the highest level branch at which the user variable is visible.")]
        HRESULT TopVisBranch([out, retval] ILEAPBranch** Value);
        [id(0x000000d5), propput, helpstring("Gets or sets the highest level branch at which the user variable is visible.")]
        HRESULT TopVisBranch([in] ILEAPBranch* Value);
        [id(0x000000d6), propget, helpstring("Gets or sets the number of levels below TopVisibleBranch at which the user variable is shown.  -1=None, 0=All levels below.")]
        HRESULT VisibleLevelsBelow([out, retval] int* Value);
        [id(0x000000d6), propput, helpstring("Gets or sets the number of levels below TopVisibleBranch at which the user variable is shown.  -1=None, 0=All levels below.")]
        HRESULT VisibleLevelsBelow([in] int Value);
        [id(0x000000d7), propget, helpstring("Gets or sets if variable is read-only in Current Accounts.")]
        HRESULT ReadOnlyCurrentAccounts([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d7), propput, helpstring("Gets or sets if variable is read-only in Current Accounts.")]
        HRESULT ReadOnlyCurrentAccounts([in] VARIANT_BOOL Value);
        [id(0x000000d8), propget, helpstring("Gets or sets if variable is read-only in all scenarios.")]
        HRESULT ReadOnlyScenarios([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d8), propput, helpstring("Gets or sets if variable is read-only in all scenarios.")]
        HRESULT ReadOnlyScenarios([in] VARIANT_BOOL Value);
        [id(0x000000d9), propget, helpstring("Gets or sets if user variable is an intermediate variable (one that can be hidden).")]
        HRESULT Intermediate([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d9), propput, helpstring("Gets or sets if user variable is an intermediate variable (one that can be hidden).")]
        HRESULT Intermediate([in] VARIANT_BOOL Value);
        [id(0x000000da), propget, helpstring("Gets or sets the default Current Accounts expression for the user variable.  Can be a simple value or an expression.")]
        HRESULT DefaultExpressionCurrentAccounts([out, retval] BSTR* Value);
        [id(0x000000da), propput, helpstring("Gets or sets the default Current Accounts expression for the user variable.  Can be a simple value or an expression.")]
        HRESULT DefaultExpressionCurrentAccounts([in] BSTR Value);
        [id(0x000000db), propget, helpstring("Gets or sets the default scenario expression for the user variable.  Can be a simple value or an expression. Leave blank to default to the Current Accounts default expression.")]
        HRESULT DefaultExpressionScenarios([out, retval] BSTR* Value);
        [id(0x000000db), propput, helpstring("Gets or sets the default scenario expression for the user variable.  Can be a simple value or an expression. Leave blank to default to the Current Accounts default expression.")]
        HRESULT DefaultExpressionScenarios([in] BSTR Value);
        [id(0x000000dc), propget, helpstring("Gets or sets if user variable is time-sliced.")]
        HRESULT TimeSliced([out, retval] VARIANT_BOOL* Value);
        [id(0x000000dc), propput, helpstring("Gets or sets if user variable is time-sliced.")]
        HRESULT TimeSliced([in] VARIANT_BOOL Value);
    };

    [
      uuid(EABEF2D7-1083-4DEE-853E-FF1A59819181),
      version(1.0),
      helpstring("LEAPUserVariable Object")
    ]
    coclass LEAPUserVariable {
        [default] interface ILEAPUserVariable;
    };

    [
      odl,
      uuid(319F777F-17BA-40E1-94FE-0EF04C505407),
      version(1.0),
      helpstring("Dispatch interface for LEAPUserVariables Object"),
      dual,
      oleautomation
    ]
    interface ILEAPUserVariables : IDispatch {
        [id(0x000000c9), propget, helpstring("The number of user variables in the collection.")]
        HRESULT Count([out, retval] long* Value);
        [id(0xfffffffc), propget, hidden]
        HRESULT _NewEnum([out, retval] IUnknown** Value);
        [id(00000000), propget, helpstring("Get user variable object by name ("variable name"), by index (1..count) or ("IX:XXX") or by ID ("ID:XXX"). Default property.")]
        HRESULT Item(
                        [in] VARIANT Index, 
                        [out, retval] ILEAPUserVariable** Value);
        [id(0x000000cb), helpstring("Adds and returns a reference to a new named User Variable.")]
        HRESULT Add(
                        [in] BSTR UVName, 
                        [in] int Scale, 
                        [in] BSTR UnitStr, 
                        [out, retval] ILEAPUserVariable** Result);
        [id(0x000000cc), helpstring("Deletes the User Variable referenced by its name or ID.  Use with caution!")]
        HRESULT Delete([in] VARIANT NameOrID);
    };

    [
      uuid(2D1C5011-0690-463A-B0B2-4B76BAA3CBD3),
      version(1.0),
      helpstring("LEAPUserVariables Object")
    ]
    coclass LEAPUserVariables {
        [default] interface ILEAPUserVariables;
    };

    [
      odl,
      uuid(5D4D27B4-D30B-4940-8585-C4FD7E072471),
      version(1.0),
      helpstring("Dispatch interface for LEAPEffects Object"),
      dual,
      oleautomation
    ]
    interface ILEAPEffects : IDispatch {
        [id(0x000000c9), propget, helpstring("The number of effects (pollutants) in the collection.")]
        HRESULT Count([out, retval] long* Value);
        [id(0xfffffffc), propget, hidden]
        HRESULT _NewEnum([out, retval] IUnknown** Value);
        [id(00000000), propget, helpstring("Get an effect object by name ("effect name"), by index (1..count) or ("IX:XXX"),  by ID ("ID:XXX") or by branch ID ("BR:XXX").  Default property. Returns error if effect does not exist.  Use Exists first.")]
        HRESULT Item(
                        [in] VARIANT Index, 
                        [out, retval] ILEAPEffect** Value);
        [id(0x000000ca), helpstring("Tests if the named effect exists in the current area. Accepts effect name or abbreviation.")]
        HRESULT Exists(
                        [in] BSTR Name, 
                        [out, retval] VARIANT_BOOL* Result);
    };

    [
      uuid(C3287245-9177-4073-8AD8-947E1DE798F2),
      version(1.0),
      helpstring("LEAPEffects Object")
    ]
    coclass LEAPEffects {
        [default] interface ILEAPEffects;
    };

    [
      odl,
      uuid(A37834EB-95E3-448C-9E1D-8B273EFA6481),
      version(1.0),
      helpstring("Dispatch interface for LEAPEffect Object"),
      dual,
      oleautomation
    ]
    interface ILEAPEffect : IDispatch {
        [id(0x000000c9), hidden]
        HRESULT Init([in] int ID);
        [id(0x000000ca), propget, helpstring("The name of the effect (e.g. methane).")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(0x000000ca), propput, helpstring("The name of the effect (e.g. methane).")]
        HRESULT Name([in] BSTR Value);
        [id(0x000000cb), propget, helpstring("The unique ID number of the effect.")]
        HRESULT ID([out, retval] int* Value);
        [id(0x000000ce), propget, helpstring("Gets or sets the abbreviation for the effect.")]
        HRESULT Abbreviation([out, retval] BSTR* Value);
        [id(0x000000ce), propput, helpstring("Gets or sets the abbreviation for the effect.")]
        HRESULT Abbreviation([in] BSTR Value);
        [id(0x000000cf), propget, helpstring("Gets or sets the ID of the unit in which the effect is measured.")]
        HRESULT UnitID([out, retval] int* Value);
        [id(0x000000cf), propput, helpstring("Gets or sets the ID of the unit in which the effect is measured.")]
        HRESULT UnitID([in] int Value);
        [id(0x000000d0), propget, helpstring("Gets or sets the 100 year global warming potential of the effect (in tonnes CO2 equivalent/tonne)")]
        HRESULT GWP20([out, retval] double* Value);
        [id(0x000000d0), propput, helpstring("Gets or sets the 100 year global warming potential of the effect (in tonnes CO2 equivalent/tonne)")]
        HRESULT GWP20([in] double Value);
        [id(0x000000d1), propget, helpstring("The index number of the effect from 1..LEAP.Effects.Count.")]
        HRESULT Index([out, retval] int* Value);
        [id(0x000000cc), propget]
        HRESULT GWP100([out, retval] double* Value);
        [id(0x000000cc), propput]
        HRESULT GWP100([in] double Value);
        [id(0x000000cd), propget]
        HRESULT GWP500([out, retval] double* Value);
        [id(0x000000cd), propput]
        HRESULT GWP500([in] double Value);
    };

    [
      uuid(87277989-9C71-44EC-9574-A7A0ABB04CBC),
      version(1.0),
      helpstring("LEAPEffect Object")
    ]
    coclass LEAPEffect {
        [default] interface ILEAPEffect;
    };

    [
      odl,
      uuid(B1193FCD-11F4-4510-9C8A-3C750863F117),
      version(1.0),
      helpstring("Dispatch interface for TEDTechnologies Object"),
      dual,
      oleautomation
    ]
    interface ITEDTechnologies : IDispatch {
        [id(0x000000c9), propget, helpstring("The number of TED technologies in the collection.")]
        HRESULT Count([out, retval] long* Value);
        [id(0xfffffffc), propget, hidden]
        HRESULT _NewEnum([out, retval] IUnknown** Value);
        [id(00000000), propget, helpstring("Gets the TED technology identified by name or index (from 1 to TEDTechnologies.Count). Default property.")]
        HRESULT Item(
                        [in] VARIANT Index, 
                        [out, retval] ITEDTechnology** Value);
    };

    [
      uuid(046639BC-4678-4501-BF02-2E05CE076046),
      version(1.0),
      helpstring("TEDTechnologies Object")
    ]
    coclass TEDTechnologies {
        [default] interface ITEDTechnologies;
    };

    [
      odl,
      uuid(B4C52499-5461-403A-83EA-DE3098FAAAD5),
      version(1.0),
      helpstring("Dispatch interface for TEDTechnology Object"),
      dual,
      oleautomation
    ]
    interface ITEDTechnology : IDispatch {
        [id(0x000000c9), hidden]
        HRESULT Init([in] int TEDID);
        [id(0x000000ca), propget, helpstring("The unique ID of the TED branch structure of the referenced TED technology.")]
        HRESULT ID([out, retval] int* Value);
        [id(0x000000cb), propget, helpstring("The name of the TED technology. Default property.")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(0x000000cb), propput, helpstring("The name of the TED technology. Default property.")]
        HRESULT Name([in] BSTR Value);
        [id(0x000000cc), propget, helpstring("The full path name of the TED technology.")]
        HRESULT FullName([out, retval] BSTR* Value);
        [id(0x000000cd), propget, helpstring("Returns true if the technology record contains quantitative data.")]
        HRESULT ContainsData([out, retval] VARIANT_BOOL* Value);
        [id(0x000000ce), propget, helpstring("Returns the year in which the technology was or will be available.")]
        HRESULT AvailableYear([out, retval] long* Value);
        [id(0x000000cf), propget, helpstring("Returns the lifetime in years of the technology.")]
        HRESULT Lifetime([out, retval] long* Value);
        [id(0x000000d0), propget, helpstring("Returns true if the technology record includes capacity data.")]
        HRESULT CapacityData([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d1), propget, helpstring("Returns true if the technology record includes efficiency data.")]
        HRESULT EfficiencyData([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d2), propget, helpstring("Returns true if the technology record includes cost data.")]
        HRESULT CostData([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d3), propget, helpstring("Returns true if the technology record includes emissions data.")]
        HRESULT EmissionsData([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d4), propget, helpstring("Gets the input fuel of the technology. Returned as a LEAPFuel object.")]
        HRESULT InputFuel([out, retval] ILEAPFuel** Value);
        [id(0x000000d5), propget, helpstring("Gets the output fuel of the technology. Returned as a LEAPFuel object.")]
        HRESULT OutputFuel([out, retval] ILEAPFuel** Value);
        [id(0x000000d6), propget, helpstring("The unique ID in the TED branch structure of parent of the referenced TED technology.")]
        HRESULT ParentID([out, retval] int* Value);
    };

    [
      uuid(9D70BDB7-C140-45EB-895A-2DCDDB4D701E),
      version(1.0),
      helpstring("TEDTechnology Object")
    ]
    coclass TEDTechnology {
        [default] interface ITEDTechnology;
    };

    [
      odl,
      uuid(12447876-D986-4B6F-ADF5-5DD244F2D590),
      version(1.0),
      helpstring("Dispatch interface for ResultDimension Object"),
      dual,
      oleautomation
    ]
    interface ILEAPDimension : IDispatch {
        [id(0x000000c9), propget, helpstring("The name of the dimension (e.g. years, fuels, branches, regions, scenarios, etc.).")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(0x000000ca), propget, helpstring("Not implemented.")]
        HRESULT Active([out, retval] VARIANT_BOOL* Value);
        [id(0x000000ca), propput, helpstring("Not implemented.")]
        HRESULT Active([in] VARIANT_BOOL Value);
        [id(0x000000cb), hidden]
        HRESULT Init([in] int DimID);
        [id(0x000000cd), propget, helpstring("The unique ID of the dimension.")]
        HRESULT ID([out, retval] int* Value);
        [id(0x000000cc), propget, helpstring("The index number of the dimension from 1..LEAP.Dimensions.Count.")]
        HRESULT Index([out, retval] int* Value);
    };

    [
      uuid(859B38FF-D2CA-4043-95AE-C29729AF0C6E),
      version(1.0),
      helpstring("ResultDimension Object")
    ]
    coclass LEAPDimension {
        [default] interface ILEAPDimension;
    };

    [
      odl,
      uuid(9C1A0B83-4636-44A5-B0F5-A4A9AEDA0A4C),
      version(1.0),
      helpstring("Dispatch interface for LEAPDimensions Object"),
      dual,
      oleautomation
    ]
    interface ILEAPDimensions : IDispatch {
        [id(0x000000c9), propget, helpstring("The number of dimensions in the collection.")]
        HRESULT Count([out, retval] long* Value);
        [id(0xfffffffc), propget, hidden]
        HRESULT _NewEnum([out, retval] IUnknown** Value);
        [id(00000000), propget, helpstring("Gets the dimension identified by name or index (from 1 to Dimensions.Count). Default property.")]
        HRESULT Item(
                        [in] VARIANT Index, 
                        [out, retval] ILEAPDimension** Value);
    };

    [
      uuid(7F1BDA7C-D523-4B82-BA07-8C68D7E8AD39),
      version(1.0),
      helpstring("LEAPDimensions Object")
    ]
    coclass LEAPDimensions {
        [default] interface ILEAPDimensions;
    };

    [
      odl,
      uuid(A8B487F7-E2C5-4580-B888-06015DCE531F),
      helpstring("Dispatch interface for LEAPTimeSlice Object"),
      dual,
      oleautomation
    ]
    interface ILEAPTimeSlice : IDispatch {
        [id(0x000000c9), propget, helpstring("The name of the timeslice (e.g. summer day, winter night). Default property.")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(0x000000c9), propput, helpstring("The name of the timeslice (e.g. summer day, winter night). Default property.")]
        HRESULT Name([in] BSTR Value);
        [id(0x000000cd), propget, helpstring("The unique ID of the timeslice.")]
        HRESULT ID([out, retval] int* Value);
        [id(0x000000ca), propget, helpstring("The length of the timeslice in hours.")]
        HRESULT Hours([out, retval] double* Value);
        [id(0x000000ca), propput, helpstring("The length of the timeslice in hours.")]
        HRESULT Hours([in] double Value);
        [id(0x000000cb), propget, helpstring("The order of the timeslice.")]
        HRESULT Order([out, retval] int* Value);
        [id(0x000000cb), propput, helpstring("The order of the timeslice.")]
        HRESULT Order([in] int Value);
        [id(0x000000cc), propget, helpstring("The dispatch period of the slice: corresponds to one of four sets of values for availability and merit order for dispatching Transformation processes.")]
        HRESULT DispatchPeriod([out, retval] int* Value);
        [id(0x000000cc), propput, helpstring("The dispatch period of the slice: corresponds to one of four sets of values for availability and merit order for dispatching Transformation processes.")]
        HRESULT DispatchPeriod([in] int Value);
        [id(0x000000ce), hidden]
        HRESULT Init([in] int ID);
        [id(0x000000cf), propget, helpstring("The ID of the timestep in WEAP to which this LEAP timeslice is mapped.")]
        HRESULT WEAPTimeStepID([out, retval] int* Value);
        [id(0x000000cf), propput, helpstring("The ID of the timestep in WEAP to which this LEAP timeslice is mapped.")]
        HRESULT WEAPTimeStepID([in] int Value);
        [id(0x000000d0), propget, helpstring("The start time of the day for hours in this slice (0..24).")]
        HRESULT BeginHour([out, retval] int* Value);
        [id(0x000000d0), propput, helpstring("The start time of the day for hours in this slice (0..24).")]
        HRESULT BeginHour([in] int Value);
        [id(0x000000d1), propget, helpstring("The ending time of the day for hours in this slice (0..24).")]
        HRESULT EndHour([out, retval] long* Value);
        [id(0x000000d1), propput, helpstring("The ending time of the day for hours in this slice (0..24).")]
        HRESULT EndHour([in] long Value);
        [id(0x000000d2), propget, helpstring("The starting date for days in this slice (e.g. 12/21).")]
        HRESULT BeginDate([out, retval] BSTR* Value);
        [id(0x000000d2), propput, helpstring("The starting date for days in this slice (e.g. 12/21).")]
        HRESULT BeginDate([in] BSTR Value);
        [id(0x000000d3), propget, helpstring("The ending date for days in this slice (e.g. 12/21).")]
        HRESULT EndDate([out, retval] BSTR* Value);
        [id(0x000000d3), propput, helpstring("The ending date for days in this slice (e.g. 12/21).")]
        HRESULT EndDate([in] BSTR Value);
        [id(0x000000d4), propget, helpstring("If Mondays are included in this slice.")]
        HRESULT Monday([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d5), propget, helpstring("If Tuesdays are included in this slice.")]
        HRESULT Tuesday([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d6), propget, helpstring("If Wednesdays are included in this slice.")]
        HRESULT Wednesday([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d7), propget, helpstring("If Thursdays are included in this slice.")]
        HRESULT Thursday([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d8), propget, helpstring("If Fridays are included in this slice.")]
        HRESULT Friday([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d9), propget, helpstring("If Saturdays are included in this slice.")]
        HRESULT Saturday([out, retval] VARIANT_BOOL* Value);
        [id(0x000000da), propget, helpstring("If Sundays are included in this slice.")]
        HRESULT Sunday([out, retval] VARIANT_BOOL* Value);
        [id(0x000000db), propget, hidden, helpstring("An integer "tag" variable: for any user-defined data.")]
        HRESULT Tag([out, retval] int* Value);
        [id(0x000000db), propput, hidden, helpstring("An integer "tag" variable: for any user-defined data.")]
        HRESULT Tag([in] int Value);
        [id(0x000000dc), propget, helpstring("One of three floating point variables for use by the user.")]
        HRESULT User1([out, retval] double* Value);
        [id(0x000000dc), propput, helpstring("One of three floating point variables for use by the user.")]
        HRESULT User1([in] double Value);
        [id(0x000000dd), propget, helpstring("One of three floating point variables for use by the user.")]
        HRESULT User2([out, retval] double* Value);
        [id(0x000000dd), propput, helpstring("One of three floating point variables for use by the user.")]
        HRESULT User2([in] double Value);
        [id(0x000000de), propget, helpstring("One of three floating point variables for use by the user.")]
        HRESULT User3([out, retval] double* Value);
        [id(0x000000de), propput, helpstring("One of three floating point variables for use by the user.")]
        HRESULT User3([in] double Value);
        [id(0x000000df), propget, helpstring("The month the time slice begins (integer from 1..12)")]
        HRESULT BeginDateMonth([out, retval] int* Value);
        [id(0x000000df), propput, helpstring("The month the time slice begins (integer from 1..12)")]
        HRESULT BeginDateMonth([in] int Value);
        [id(0x000000e0), propget, helpstring("The month the time slice ends (integer from 1..12)")]
        HRESULT EndDateMonth([out, retval] int* Value);
        [id(0x000000e0), propput, helpstring("The month the time slice ends (integer from 1..12)")]
        HRESULT EndDateMonth([in] int Value);
        [id(0x000000e1), propget, helpstring("The day of the moth the time slice begins (integer from 1..31)")]
        HRESULT BeginDateDay([out, retval] int* Value);
        [id(0x000000e1), propput, helpstring("The day of the moth the time slice begins (integer from 1..31)")]
        HRESULT BeginDateDay([in] int Value);
        [id(0x000000e2), propget, helpstring("The day of the moth the time slice ends (integer from 1..31)")]
        HRESULT EndDateDay([out, retval] int* Value);
        [id(0x000000e2), propput, helpstring("The day of the moth the time slice ends (integer from 1..31)")]
        HRESULT EndDateDay([in] int Value);
        [id(0x000000e3), propget, helpstring("The abbreviation for the timeslice.")]
        HRESULT Abbreviation([out, retval] BSTR* Value);
        [id(0x000000e3), propput, helpstring("The abbreviation for the timeslice.")]
        HRESULT Abbreviation([in] BSTR Value);
        [id(0x000000e4), propget, helpstring("The notes for the timeslice.")]
        HRESULT Notes([out, retval] BSTR* Value);
        [id(0x000000e4), propput, helpstring("The notes for the timeslice.")]
        HRESULT Notes([in] BSTR Value);
        [id(0x000000e5), propget, helpstring("The cumulative hours in this and all earlier time slices.")]
        HRESULT CumulativeHours([out, retval] double* Value);
        [id(0x000000e6), propget, helpstring("The index number of the timeslice from 1..LEAP.TimeSlices.Count.")]
        HRESULT Index([out, retval] long* Value);
    };

    [
      uuid(FF5B65AC-BD17-4A04-8DC4-A8352F1DA529),
      version(1.0),
      helpstring("LEAPTimeSlice Object")
    ]
    coclass LEAPTimeSlice {
        [default] interface ILEAPTimeSlice;
    };

    [
      odl,
      uuid(9DD706EC-FA92-48C7-A5F2-1E84DA05315D),
      version(1.0),
      helpstring("Dispatch interface for LEAPTimeSlices Object"),
      dual,
      oleautomation
    ]
    interface ILEAPTimeSlices : IDispatch {
        [id(0x000000c9), propget, helpstring("The number of timeslices in the collection.")]
        HRESULT Count([out, retval] long* Value);
        [id(0xfffffffc), propget, hidden]
        HRESULT _NewEnum([out, retval] IUnknown** Value);
        [id(00000000), propget, helpstring("Gets timeslice by name, index (1..count) or ID (syntax ID:XXX). Default property.")]
        HRESULT Item(
                        [in] VARIANT Index, 
                        [out, retval] ILEAPTimeSlice** Value);
    };

    [
      uuid(6257B6A6-8BFE-4AB6-B2E7-60E680578F4B),
      version(1.0),
      helpstring("LEAPTimeSlices Object")
    ]
    coclass LEAPTimeSlices {
        [default] interface ILEAPTimeSlices;
    };

    [
      odl,
      uuid(1401A890-305B-42D7-A64D-8D871E3DBC7B),
      version(1.0),
      helpstring("Dispatch interface for LEAPYearlyShape Object"),
      dual,
      oleautomation
    ]
    interface ILEAPYearlyShape : IDispatch {
        [id(0x000000c9), propget, helpstring("The name of the yearly shape (e.g. load shapes for lighting, refrigeration, day peak, night peak, etc.). Default property.")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(0x000000c9), propput, helpstring("The name of the yearly shape (e.g. load shapes for lighting, refrigeration, day peak, night peak, etc.). Default property.")]
        HRESULT Name([in] BSTR Value);
        [id(0x000000ca), propget, helpstring("The unique ID of the yearly shape.")]
        HRESULT ID([out, retval] int* Value);
        [id(0x000000cb), hidden]
        HRESULT Init([in] int ID);
        [id(0x000000cc), propget, helpstring("The order of the yearly shape.")]
        HRESULT Order([out, retval] int* Value);
        [id(0x000000cc), propput, helpstring("The order of the yearly shape.")]
        HRESULT Order([in] int Value);
        [id(0x000000cd), propget, helpstring("Notes describing the yearly shape.")]
        HRESULT Notes([out, retval] BSTR* Value);
        [id(0x000000cd), propput, helpstring("Notes describing the yearly shape.")]
        HRESULT Notes([in] BSTR Value);
        [id(0x000000ce), propget, helpstring("The type of the yearly shape (0=energy load shape, 1=peak load shape, 2=availability, 3=merit order)")]
        HRESULT ProfileType([out, retval] int* Value);
        [id(0x000000ce), propput, helpstring("The type of the yearly shape (0=energy load shape, 1=peak load shape, 2=availability, 3=merit order)")]
        HRESULT ProfileType([in] int Value);
        [id(0x000000cf), propget, hidden, helpstring("An integer "tag" variable: for any user-defined data.")]
        HRESULT Tag([out, retval] int* Value);
        [id(0x000000cf), propput, hidden, helpstring("An integer "tag" variable: for any user-defined data.")]
        HRESULT Tag([in] int Value);
        [id(0x000000d0), propget, helpstring("One of three floating point variables for use by the user.")]
        HRESULT User1([out, retval] double* Value);
        [id(0x000000d0), propput, helpstring("One of three floating point variables for use by the user.")]
        HRESULT User1([in] double Value);
        [id(0x000000d1), propget, helpstring("One of three floating point variables for use by the user.")]
        HRESULT User2([out, retval] double* Value);
        [id(0x000000d1), propput, helpstring("One of three floating point variables for use by the user.")]
        HRESULT User2([in] double Value);
        [id(0x000000d2), propget, helpstring("One of three floating point variables for use by the user.")]
        HRESULT User3([out, retval] double* Value);
        [id(0x000000d2), propput, helpstring("One of three floating point variables for use by the user.")]
        HRESULT User3([in] double Value);
        [id(0x000000d3), propget, helpstring("Gets the value of the yearly shape for the specified time slice (specified as slice name or ID).")]
        HRESULT Value(
                        [in] VARIANT TimeSliceNameOrID, 
                        [out, retval] double* Value);
        [id(0x000000d4), propget, helpstring("The type of the yearly shape (text description).")]
        HRESULT ProfileTypeDescription([out, retval] BSTR* Value);
        [id(0x000000d5), propget, helpstring("The index number of the yearly shape from 1..LEAP.YearlyShapes.Count.")]
        HRESULT Index([out, retval] int* Value);
    };

    [
      uuid(2DCA15DA-0898-4232-9632-BE8472DAE1DB),
      version(1.0),
      helpstring("LEAPYearlyShape Object")
    ]
    coclass LEAPYearlyShape {
        [default] interface ILEAPYearlyShape;
    };

    [
      odl,
      uuid(E3FBB669-DDD2-44D5-A7E2-9A86C5FB28F3),
      version(1.0),
      helpstring("Dispatch interface for LEAPYearlyShapes Object"),
      dual,
      oleautomation
    ]
    interface ILEAPYearlyShapes : IDispatch {
        [id(0x000000c9), propget, helpstring("The number of yearly shapes in the collection.")]
        HRESULT Count([out, retval] long* Value);
        [id(0xfffffffc), propget, hidden]
        HRESULT _NewEnum([out, retval] IUnknown** Value);
        [id(00000000), propget, helpstring("Get yearly shape by name, index (1..count) or ID (syntax ID:XXX). Default property.")]
        HRESULT Item(
                        [in] VARIANT Index, 
                        [out, retval] ILEAPYearlyShape** Value);
    };

    [
      uuid(C8BB1973-4F9C-4890-96A5-C8EF55735323),
      version(1.0),
      helpstring("LEAPYearlyShapes Object")
    ]
    coclass LEAPYearlyShapes {
        [default] interface ILEAPYearlyShapes;
    };

    [
      odl,
      uuid(ABFB7556-BBA0-4668-B984-8A467DD2FD8A),
      helpstring("Dispatch interface for AutoWEAPLinkage Object"),
      dual,
      oleautomation
    ]
    interface IAutoWEAPLinkage : IDispatch {
        [id(0x000000c9), propget]
        HRESULT Area([out, retval] BSTR* Value);
        [id(0x000000c9), propput]
        HRESULT Area([in] BSTR Value);
        [id(0x000000ca), propget]
        HRESULT LinkedLEAPScenario(
                        [in] long WEAPScenarioID, 
                        [in] BSTR WEAPScenarioName, 
                        [out, retval] long* Value);
        [id(0x000000ca), propput]
        HRESULT LinkedLEAPScenario(
                        [in] long WEAPScenarioID, 
                        [in] BSTR WEAPScenarioName, 
                        [in] long Value);
        [id(0x000000cb), propget]
        HRESULT LinkedLEAPTimestep(
                        [in] long WEAPTimesliceID, 
                        [in] BSTR WEAPTimesliceName, 
                        [out, retval] long* Value);
        [id(0x000000cb), propput]
        HRESULT LinkedLEAPTimestep(
                        [in] long WEAPTimesliceID, 
                        [in] BSTR WEAPTimesliceName, 
                        [in] long Value);
        [id(0x000000cc), propget]
        HRESULT InitCalculations([out, retval] VARIANT_BOOL* Value);
        [id(0x000000cd)]
        HRESULT FinalizeCalculations();
        [id(0x000000ce), propget]
        HRESULT VarRef(
                        [in] BSTR CompiledVarRef, 
                        [in] long WEAPBranchID, 
                        [in] long WEAPVariableID, 
                        [in] long WEAPScenarioID, 
                        [in] long YearID, 
                        [in] long WEAPTimeStepID, 
                        [in, out, defaultvalue(0)] long* ErrorCode, 
                        [out, retval] double* Value);
        [id(0x000000cf), helpstring("Forces LEAP's LEAP/WEAP link screen to refresh ")]
        HRESULT RefreshLinks();
        [id(0x000000d0), helpstring("Event that occurs when WEAP is closing.  Used to tell LEAP to set its pointer to WEAP to nil.")]
        HRESULT WEAPClosing();
        [id(0x000000d1), propget, hidden, helpstring("If currently reading the linkage information")]
        HRESULT InReadLinkageInfo([out, retval] VARIANT_BOOL* Value);
    };

    [
      uuid(12997C78-6754-449D-8F19-B7914FC93EE4),
      helpstring("AutoWEAPLinkage Object")
    ]
    coclass AutoWEAPLinkage {
        [default] interface IAutoWEAPLinkage;
    };

    [
      odl,
      uuid(CDDD6180-D43A-4E99-9DC5-A9AD3465E780),
      helpstring("Dispatch interface for Tags Object"),
      dual,
      oleautomation
    ]
    interface ILEAPTags : IDispatch {
        [id(0x000000c9), propget, helpstring("The number of tags.")]
        HRESULT Count([out, retval] long* Value);
        [id(00000000), propget, helpstring("Gets tags by name ("tag name"), by index (1..count) or ("IX:XXX") or by ID ("ID:XXX). Default property.")]
        HRESULT Item(
                        [in] VARIANT Index, 
                        [out, retval] ILEAPTag** Value);
        [id(0xfffffffc), propget, hidden]
        HRESULT _NewEnum([out, retval] IUnknown** Value);
        [id(0x000000ca), propget, helpstring("The maximum ID of all tags in the collection.")]
        HRESULT MaxID([out, retval] int* Value);
        [id(0x000000cb), helpstring("Tests if the named tag exists in the current area. Accepts tag name as parameter.")]
        HRESULT Exists(
                        [in] BSTR TagName, 
                        [out, retval] VARIANT_BOOL* Result);
        [id(0x000000cc), helpstring("Adds a new tag either at a branch or to the collection of all tags. When adding to a collection of tags at a branch, you can specify a new tag name or an existing tag name or ID or an existing tag object.  When adding to the overall area-wide collection of tags you must specify a new tag name. You can also optionally tag any branches below the current branch with the same tag.")]
        HRESULT Add(
                        [in] VARIANT Tag, 
                        [in, optional, defaultvalue(0)] VARIANT_BOOL AddToChildren);
        [id(0x000000cd), helpstring("Deletes a tag either from the list of tags at a particular branch or from the area-wide collection of tags.  When deleting from the collection of tags at a branch, the tag will not be removed from the overall area-wide list of tags. When deleting from the collection of tags at a branch, you can also optionally delete the tag at any branches below the current branch. Tags can be specied by name or ID or as a tag object. ")]
        HRESULT Delete(
                        [in] VARIANT Tag, 
                        [in, optional, defaultvalue(0)] VARIANT_BOOL DelFromChildren);
        [id(0x000000ce), hidden]
        HRESULT Init([in] int BranchID);
    };

    [
      uuid(997281CA-E85A-4D87-A029-FBA4F6B6CBC1),
      helpstring("LEAPTags Object")
    ]
    coclass LEAPTags {
        [default] interface ILEAPTags;
    };

    [
      odl,
      uuid(A63B2C71-9D31-4C53-B8A0-8C2926344F5F),
      helpstring("Dispatch interface for LEAPTag Object"),
      dual,
      oleautomation
    ]
    interface ILEAPTag : IDispatch {
        [id(0x000000c9), hidden]
        HRESULT Init(
                        [in] int ID, 
                        [in] int BranchID);
        [id(0x000000ca), propget, helpstring("The name of the tag. Default property.")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(0x000000ca), propput, helpstring("The name of the tag. Default property.")]
        HRESULT Name([in] BSTR Value);
        [id(0x000000cc), propget, helpstring("The description of the tag.")]
        HRESULT Description([out, retval] BSTR* Value);
        [id(0x000000cc), propput, helpstring("The description of the tag.")]
        HRESULT Description([in] BSTR Value);
        [id(0x000000cd), propget, helpstring("The unique ID of the tag.")]
        HRESULT ID([out, retval] int* Value);
        [id(0x000000ce), propget, helpstring("The display order of the tag.")]
        HRESULT Order([out, retval] int* Value);
        [id(0x000000ce), propput, helpstring("The display order of the tag.")]
        HRESULT Order([in] int Value);
        [id(0x000000cf), propget, helpstring("Get or set the color of the tag: white, blue, green, yellow, orange, purple, or pink.")]
        HRESULT Color([out, retval] BSTR* Value);
        [id(0x000000cf), propput, helpstring("Get or set the color of the tag: white, blue, green, yellow, orange, purple, or pink.")]
        HRESULT Color([in] BSTR Value);
        [id(0x000000cb), propget, helpstring("The tag group associated with a tag.")]
        HRESULT TagGroup([out, retval] ILEAPTagGroup** Value);
        [id(0x000000cb), propput, helpstring("The tag group associated with a tag.")]
        HRESULT TagGroup([in] ILEAPTagGroup* Value);
        [id(0x000000d0), propget, helpstring("Gets the collection of branches that have the tag.")]
        HRESULT Branches([out, retval] ILEAPBranches** Value);
    };

    [
      uuid(88C21B36-4916-4F5F-94BC-09BD81A9A193),
      helpstring("LEAPTag Object")
    ]
    coclass LEAPTag {
        [default] interface ILEAPTag;
    };

    [
      odl,
      uuid(7ACEE759-8480-46AC-A787-07C3E6B79ECA),
      helpstring("Dispatch interface for LEAPTagGroups Object"),
      dual,
      oleautomation
    ]
    interface ILEAPTagGroups : IDispatch {
        [id(0x000000c9), propget, helpstring("The number of tag groups.")]
        HRESULT Count([out, retval] long* Value);
        [id(00000000), propget, helpstring("Gets a tag group object by name ("tag group name"), by index (1..count) or ("IX:XXX:"), or by ID ("ID:XXX"). Default property. ")]
        HRESULT Item(
                        [in] VARIANT Index, 
                        [out, retval] ILEAPTagGroup** Value);
        [id(0x000000cb), helpstring("Tests if the named tag group exists in the current area. Accepts tag group name as parameter.")]
        HRESULT Exists(
                        [in] BSTR Name, 
                        [out, retval] VARIANT_BOOL* Result);
        [id(0x000000cc)]
        HRESULT Init();
        [id(0x000000cd), helpstring("Adds a new tag group to the area-wide collection of tags groups. Specify a name of the tag group as the parameter.")]
        HRESULT Add([in] VARIANT TagGroup);
        [id(0x000000ce), helpstring("Deletes a tag group. Specify the tag group by name, ID or tag group object.")]
        HRESULT Delete([in] VARIANT TagGroup);
        [id(0xfffffffc), propget, hidden]
        HRESULT _NewEnum([out, retval] IUnknown** Value);
        [id(0x000000cf), propget, helpstring("The maximum ID of all tag groups in the tag group collection.")]
        HRESULT MaxID([out, retval] int* Value);
    };

    [
      uuid(E6F785CF-4340-441E-A391-1ED001ED2807),
      helpstring("Dispatch Interface for LEAPTagGroups Object")
    ]
    coclass LEAPTagGroups {
        [default] interface ILEAPTagGroups;
    };

    [
      odl,
      uuid(764A42ED-6756-49C1-9607-374D16FD9D51),
      helpstring("Dispatch interface for LEAPTagGroup Object"),
      dual,
      oleautomation
    ]
    interface ILEAPTagGroup : IDispatch {
        [id(0x000000c9), hidden]
        HRESULT Init([in] int ID);
        [id(0x000000ca), propget, helpstring("The name of the tag group. Default property.")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(0x000000ca), propput, helpstring("The name of the tag group. Default property.")]
        HRESULT Name([in] BSTR Value);
        [id(0x000000cb), propget, helpstring("The unique ID of the tag group.")]
        HRESULT ID([out, retval] int* Value);
        [id(0x000000cc), propget, helpstring("The order of the tag group.")]
        HRESULT Order([out, retval] int* Value);
        [id(0x000000cc), propput, helpstring("The order of the tag group.")]
        HRESULT Order([in] int Value);
    };

    [
      uuid(82E09FD9-1A4C-4A02-9422-3A42B854D765),
      helpstring("Dispatch interface for LEAPTagGroups Object")
    ]
    coclass LEAPTagGroup {
        [default] interface ILEAPTagGroup;
    };

    [
      odl,
      uuid(DF96C4D4-C0DC-41F7-A4EA-BD637DF15EDC),
      helpstring("Dispatch interface for LEAPFuelGroup Object"),
      dual,
      oleautomation
    ]
    interface ILEAPFuelGroup : IDispatch {
        [id(0x000000c9), propget, helpstring("The name of the fuel grouping. Default property.")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(0x000000c9), propput, helpstring("The name of the fuel grouping. Default property.")]
        HRESULT Name([in] BSTR Value);
        [id(0x000000ca), propget, helpstring("The unique ID of the fuel grouping.")]
        HRESULT ID([out, retval] int* Value);
        [id(0x000000cb), propget, helpstring("The order of the fuel group.")]
        HRESULT Order([out, retval] int* Value);
        [id(0x000000cb), propput, helpstring("The order of the fuel group.")]
        HRESULT Order([in] int Value);
        [id(0x000000cc), hidden]
        HRESULT Init(
                        [in] int ID, 
                        [in] int Group);
    };

    [
      uuid(57B8AF40-1B4A-4541-954B-9FB1A8A5AF10),
      helpstring("LEAPFuelGroup Object")
    ]
    coclass LEAPFuelGroup {
        [default] interface ILEAPFuelGroup;
    };

    [
      odl,
      uuid(0E07F456-8C65-4971-A696-3CE636FE2F03),
      helpstring("Dispatch interface for LEAPFuelGroups Object"),
      dual,
      oleautomation
    ]
    interface ILEAPFuelGroups : IDispatch {
        [id(0x000000c9), hidden]
        HRESULT Init([in] int Group);
        [id(0x000000ca), propget, helpstring("The number of items in this particular set of fuel groupings.")]
        HRESULT Count([out, retval] long* Value);
        [id(00000000), propget, helpstring("Gets a fuel group object by name ("group name"), by index (1..count) or ("IX:XXX") or by ID ("ID:XXX"). Default property.")]
        HRESULT Item(
                        [in] VARIANT Index, 
                        [out, retval] ILEAPFuelGroup** Value);
        [id(0x000000cc), helpstring("Tests if the named fuel group exists in the current fuel group set. Accepts fuel group name as parameter.")]
        HRESULT Exists(
                        [in] BSTR Name, 
                        [out, retval] VARIANT_BOOL* Result);
        [id(0x000000cd), helpstring("Adds a new fuel grouping to the current set of fuel groupings. Specify a name of the fuel group as the parameter.")]
        HRESULT Add([in] VARIANT FuelGroup);
        [id(0x000000ce), helpstring("Deletes a fuel group from the current set of fuel groupings. Specify the fuel group by name, ID or fuel group object.")]
        HRESULT Delete([in] VARIANT FuelGroup);
        [id(0xfffffffc), propget, hidden]
        HRESULT _NewEnum([out, retval] IUnknown** Value);
        [id(0x000000cf), propget, helpstring("The maximum ID of all fuel groups in the fuel group set.")]
        HRESULT MaxID([out, retval] int* Value);
        [id(0x000000d0), propget, helpstring("The name of the current set of fuel groupings (e.g. default, simple).  NB: Not the name of individual fuel groupings (such as oil products. renewables, etc.)")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(0x000000d0), propput, helpstring("The name of the current set of fuel groupings (e.g. default, simple).  NB: Not the name of individual fuel groupings (such as oil products. renewables, etc.)")]
        HRESULT Name([in] BSTR Value);
        [id(0x000000d1), propget, helpstring("The display order of the set of fuel groups.")]
        HRESULT Order([out, retval] int* Value);
        [id(0x000000d1), propput, helpstring("The display order of the set of fuel groups.")]
        HRESULT Order([in] int Value);
    };

    [
      uuid(1B0B81EE-2A0A-4124-8961-6C978EF2C803),
      helpstring("LEAPFuelGroups Object")
    ]
    coclass LEAPFuelGroups {
        [default] interface ILEAPFuelGroups;
    };

    [
      odl,
      uuid(6D63A764-A534-4CEE-A435-DA1F44980C06),
      helpstring("Dispatch interface for LEAPRegionGroup Object"),
      dual,
      oleautomation
    ]
    interface ILEAPRegionGroup : IDispatch {
        [id(0x000000c9), propget, helpstring("The name of the region grouping. Default property.")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(0x000000c9), propput, helpstring("The name of the region grouping. Default property.")]
        HRESULT Name([in] BSTR Value);
        [id(0x000000ca), propget, helpstring("The unique ID of the region grouping.")]
        HRESULT ID([out, retval] int* Value);
        [id(0x000000cb), propget, helpstring("The order of the region group.")]
        HRESULT Order([out, retval] int* Value);
        [id(0x000000cb), propput, helpstring("The order of the region group.")]
        HRESULT Order([in] int Value);
        [id(0x000000cc), hidden]
        HRESULT Init(
                        [in] int ID, 
                        [in] int Group);
    };

    [
      uuid(DFDD774F-24CB-4AFB-B455-E6142A909241),
      helpstring("LEAPRegionGroup Object")
    ]
    coclass LEAPRegionGroup {
        [default] interface ILEAPRegionGroup;
    };

    [
      odl,
      uuid(F2BD16F5-8642-4D93-88CA-0B648BE3454A),
      helpstring("Dispatch interface for LEAPRegionGroups Object"),
      dual,
      oleautomation
    ]
    interface ILEAPRegionGroups : IDispatch {
        [id(0x000000c9), hidden]
        HRESULT Init([in] int Group);
        [id(0x000000ca), propget, helpstring("The number of items in this particular set of region groupings.")]
        HRESULT Count([out, retval] long* Value);
        [id(0x000000cb), propget, helpstring("Gets a region grouping object by name ("group name"), by index (1..count) or ("IX:XXX") or by ID ("ID:XXX"). Default property. ")]
        HRESULT Item(
                        [in] VARIANT Index, 
                        [out, retval] ILEAPRegionGroup** Value);
        [id(0x000000cc), helpstring("Tests if the named region group exists in the current region group set. Accepts region group name as parameter.")]
        HRESULT Exists(
                        [in] BSTR Name, 
                        [out, retval] VARIANT_BOOL* Result);
        [id(0x000000cd), helpstring("Adds a new region grouping to the current set of region groupings. Specify a name of the region group as the parameter.")]
        HRESULT Add([in] VARIANT RegionGroup);
        [id(0x000000ce), helpstring("Deletes a region group from the current set of region groupings. Specify the region group by name, ID or region group object.")]
        HRESULT Delete([in] VARIANT RegionGroup);
        [id(0x000000cf), propget, hidden]
        HRESULT _NewEnum([out, retval] IUnknown** Value);
        [id(0x000000d0), propget, helpstring("The maximum ID of all region groups in the region group set.")]
        HRESULT MaxID([out, retval] int* Value);
        [id(0x000000d1), propget, helpstring("The name of the current set of region groupings (e.g. default, simple).  NB: Not the name of individual region groupings.")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(0x000000d1), propput, helpstring("The name of the current set of region groupings (e.g. default, simple).  NB: Not the name of individual region groupings.")]
        HRESULT Name([in] BSTR Value);
        [id(0x000000d2), propget, helpstring("The display order of the set of region groups.")]
        HRESULT Order([out, retval] int* Value);
        [id(0x000000d2), propput, helpstring("The display order of the set of region groups.")]
        HRESULT Order([in] int Value);
    };

    [
      uuid(10F5B1F7-7868-4A0F-8231-D277D8FCC2AA),
      helpstring("LEAPRegionGroups Object")
    ]
    coclass LEAPRegionGroups {
        [default] interface ILEAPRegionGroups;
    };

    [
      odl,
      uuid(E3F6D28A-030C-4410-BDC8-1CC1658F9339),
      helpstring("Dispatch interface for LEAPCountries Object"),
      dual,
      oleautomation
    ]
    interface ILEAPCountries : IDispatch {
        [id(0x000000c9), propget, helpstring("The number of countries in the collection.")]
        HRESULT Count([out, retval] long* Value);
        [id(0xfffffffc), propget, hidden]
        HRESULT _NewEnum([out, retval] IUnknown** Value);
        [id(00000000), propget, helpstring("Gets country by short or long name, or ISO3 or ISO2-letter designation ("Zimbabwe", "Zimbabwe, Republic of", "ZW", or "ZWE"), by index (1..count) or ("IX:XXX") or by ID ("ID:XXX"). Default property.")]
        HRESULT Item(
                        [in] VARIANT Index, 
                        [out, retval] ILEAPCountry** Value);
        [id(0x000000cc), helpstring("Tests if the named country exists in the current area.")]
        HRESULT Exists(
                        [in] BSTR Name, 
                        [out, retval] VARIANT_BOOL* Result);
    };

    [
      uuid(EA5CE1F6-F1F4-48E4-B148-E9E59ED54BF0),
      helpstring("LEAPCountries Object")
    ]
    coclass LEAPCountries {
        [default] interface ILEAPCountries;
    };

    [
      odl,
      uuid(292168AB-5E86-4E51-AC79-82F127E62B96),
      helpstring("Dispatch interface for LEAPCountry Object"),
      dual,
      oleautomation
    ]
    interface ILEAPCountry : IDispatch {
        [id(0x000000c9), hidden]
        HRESULT Init([in] int ID);
        [id(0x000000ca), propget, helpstring("The name of the country. Read Only.")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(0x000000ca), propput, helpstring("The name of the country. Read Only.")]
        HRESULT Name([in] BSTR Value);
        [id(0x000000cb), propget, helpstring("The unique ID of the country (used internally by LEAP - not an ISO code).")]
        HRESULT ID([out, retval] int* Value);
        [id(0x000000cc), propget, helpstring("The latitude of the central point of the country. Read Only.")]
        HRESULT Latitude([out, retval] double* Value);
        [id(0x000000cd), propget, helpstring("The longitude of the central point of the country. Read Only.")]
        HRESULT Longitude([out, retval] double* Value);
        [id(0x000000ce), propget, helpstring("The two letter (Alpha 2) ISO code of the country. Read Only.")]
        HRESULT Code2([out, retval] BSTR* Value);
        [id(0x000000cf), propget, helpstring("The three letter (Alpha 3) ISO code of the country. Read Only.")]
        HRESULT Code3([out, retval] BSTR* Value);
        [id(0x000000d0), propget, helpstring("The ISO numeric code of the country. Read Only.")]
        HRESULT CodeNum([out, retval] int* Value);
        [id(0x000000d1), propget, hidden, helpstring("The LEAP licensing tier for the country (1=Low or middle income, 2=1-1.5 x high income, 3=More than  1.5 x high income). Read Only.")]
        HRESULT Tier([out, retval] int* Value);
        [id(0x000000d2), propget, helpstring("Does LEAP's IBC extension support analysis of PM2.5 impacts for this country. Boolean. Read Only.")]
        HRESULT IBC_PM25([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d3), propget, helpstring("Does LEAP's IBC extension support analysis of ozone (O3) health impacts for this country. Boolean. Read Only.")]
        HRESULT IBC_O3Health([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d4), propget, helpstring("Does LEAP's IBC extension support analysis of ozone (O3) vegetation impacts for this country.  Boolean. Read Only.")]
        HRESULT IBC_O3Vegetation([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d5), propget, helpstring("The default zoom factor for showing this country on a map. Read Only.")]
        HRESULT Zoom([out, retval] int* Value);
        [id(0x000000d6), propget, helpstring("The country abbreviation (same as Code2). Read Only.")]
        HRESULT Abbreviation([out, retval] BSTR* Value);
        [id(0x000000d7), propget, helpstring("Is it a developing country? Boolean. Read Only.")]
        HRESULT Developing([out, retval] VARIANT_BOOL* Value);
        [id(0x000000d8), propget, helpstring("The two letter abbreviation of the global region of the country. Read Only.")]
        HRESULT Region([out, retval] BSTR* Value);
        [id(0x000000d9), propget, helpstring("The formal (long) name of the country. Read Only.")]
        HRESULT LongName([out, retval] BSTR* Value);
    };

    [
      uuid(3B14BC36-8884-4FDB-906E-551644F767C1),
      helpstring("LEAPCountry Object")
    ]
    coclass LEAPCountry {
        [default] interface ILEAPCountry;
    };

    [
      odl,
      uuid(8F02FCFE-02B2-4618-9830-3A02B651456D),
      helpstring("Dispatch interface for LEAPLandTypes Object"),
      dual,
      oleautomation
    ]
    interface ILEAPLandTypes : IDispatch {
        [id(0x000000c9), propget, helpstring("The number of land types in the collection.")]
        HRESULT Count([out, retval] long* Value);
        [id(0xfffffffc), propget, hidden]
        HRESULT _NewEnum([out, retval] IUnknown** Value);
        [id(00000000), propget, helpstring("Gets land type by name, index (1..count) or ID (syntax ID:XXX). Default property.")]
        HRESULT Item(
                        [in] VARIANT Index, 
                        [out, retval] ILEAPLandType** Value);
        [id(0x000000cc), helpstring("Tests if the named landtype exists in the current area.")]
        HRESULT Exists(
                        [in] BSTR Name, 
                        [out, retval] VARIANT_BOOL* Result);
    };

    [
      uuid(8DE06128-3654-4C5B-B27E-383125973EFF),
      helpstring("LEAPLandTypes Object")
    ]
    coclass LEAPLandTypes {
        [default] interface ILEAPLandTypes;
    };

    [
      odl,
      uuid(7E41781D-7E81-46CE-8275-2821CF4C6631),
      helpstring("Dispatch interface for LEAPLandType Object"),
      dual,
      oleautomation
    ]
    interface ILEAPLandType : IDispatch {
        [id(0x000000c9), hidden]
        HRESULT Init([in] int ID);
        [id(0x000000ca), propget, helpstring("The unique ID of the landtype.")]
        HRESULT ID([out, retval] int* Value);
        [id(0x000000cb), propget, helpstring("The name of the land type. Default property.")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(0x000000cb), propput, helpstring("The name of the land type. Default property.")]
        HRESULT Name([in] BSTR Value);
        [id(0x000000cc), propget, helpstring("The display order of the landtype.")]
        HRESULT Order([out, retval] int* Value);
        [id(0x000000cc), propput, helpstring("The display order of the landtype.")]
        HRESULT Order([in] int Value);
        [id(0x000000cd), propget, helpstring("The abbreviation of the landtype.")]
        HRESULT Abbreviation([out, retval] BSTR* Value);
        [id(0x000000cd), propput, helpstring("The abbreviation of the landtype.")]
        HRESULT Abbreviation([in] BSTR Value);
    };

    [
      uuid(73CA6BF6-027C-4A9B-ACC1-7E333B9C06F1),
      helpstring("LEAPLandType Object")
    ]
    coclass LEAPLandType {
        [default] interface ILEAPLandType;
    };

    [
      odl,
      uuid(7EB3384B-4247-4F94-9552-130BB1D8B398),
      helpstring("Dispatch Interface for LEAP Constants"),
      dual,
      oleautomation
    ]
    interface ILEAPConstants : IDispatch {
        [id(0x000000ca), propget, helpstring("The number of constants.")]
        HRESULT Count([out, retval] long* Value);
        [id(00000000), propget, helpstring("Gets constant by name, index (1..count) or ID (syntax ID:XXX). Default property.")]
        HRESULT Item(
                        [in] VARIANT Index, 
                        [out, retval] ILEAPConstant** Value);
        [id(0xfffffffc), propget, hidden]
        HRESULT _NewEnum([out, retval] IUnknown** Value);
        [id(0x000000cc), propget, helpstring("The maximum ID of all constants.")]
        HRESULT MaxID([out, retval] int* Value);
        [id(0x000000cd), helpstring("Tests if the named constant exists in the current area. Accepts name as parameter.")]
        HRESULT Exists(
                        [in] BSTR Name, 
                        [out, retval] VARIANT_BOOL* Result);
        [id(0x000000ce), helpstring("Adds a new constant to the collection of all constants. ")]
        HRESULT Add(
                        [in] BSTR Name, 
                        [in] double Value, 
                        [out, retval] ILEAPConstant** Result);
        [id(0x000000cf), helpstring("Deletes a constant from the area-wide collection of constants.")]
        HRESULT Delete([in] VARIANT NameOrID);
        [id(0x000000d0), propget, helpstring("Gets or sets the display order of the constant (1..N).")]
        HRESULT Order([out, retval] int* Value);
        [id(0x000000d0), propput, helpstring("Gets or sets the display order of the constant (1..N).")]
        HRESULT Order([in] int Value);
    };

    [
      uuid(2C64264F-BA2D-4822-8083-5AD88B43B360),
      helpstring("LEAPConstants Object")
    ]
    coclass LEAPConstants {
        [default] interface ILEAPConstants;
    };

    [
      odl,
      uuid(3A6A3CF5-565A-4899-964E-1D53402E0C3B),
      helpstring("Dispatch interface for LEAPConstant Object"),
      dual,
      oleautomation
    ]
    interface ILEAPConstant : IDispatch {
        [id(0x000000c9), hidden]
        HRESULT Init([in] int ConstantID);
        [id(0x000000ca), propget, helpstring("Gets or sets the name of the constant. Default property.")]
        HRESULT Name([out, retval] BSTR* Value);
        [id(0x000000ca), propput, helpstring("Gets or sets the name of the constant. Default property.")]
        HRESULT Name([in] BSTR Value);
        [id(0x000000cb), propget, helpstring("Gets or sets the value of the constant. ")]
        HRESULT Value([out, retval] single* Value);
        [id(0x000000cb), propput, helpstring("Gets or sets the value of the constant. ")]
        HRESULT Value([in] single Value);
        [id(0x000000cc), propget, helpstring("Gets or sets the longer description of the constant.")]
        HRESULT Description([out, retval] BSTR* Value);
        [id(0x000000cc), propput, helpstring("Gets or sets the longer description of the constant.")]
        HRESULT Description([in] BSTR Value);
        [id(0x000000cd), propget, helpstring("Gets the ID of the constant. Read Only.")]
        HRESULT ID([out, retval] int* Value);
        [id(0x000000ce), propget, helpstring("The index number of the const from 1..LEAP.Constants.Count.")]
        HRESULT Index([out, retval] int* Value);
        [id(0x000000cf), propget, helpstring("Gets whether the constant is locked.")]
        HRESULT Locked([out, retval] VARIANT_BOOL* Value);
    };

    [
      uuid(EFFB3DFF-8887-4A82-B442-BB4D792B8174),
      helpstring("LEAPConstant Object")
    ]
    coclass LEAPConstant {
        [default] interface ILEAPConstant;
    };

    typedef [uuid(ED365637-8DCD-479F-A1B9-749D50C08D92), version(1.0)]
    enum {
        bcArea = 0xffffffff,
        bcDemand = 1,
        bcKeyAssumptions = 3,
        bcTransformation = 26,
        bcResources = 4,
        bcIndicators = 0xfffffffb,
        bcNonEnergy = 0xfffffffc,
        bcStockChanges = 0xfffffffd,
        bcStatDiffs = 0xfffffffe
    } BranchConstants;

    typedef [uuid(3271FEBF-74D9-40DF-A681-76365BA0F2C7), version(1.0)]
    enum {
        scSolid = 0,
        scLiquid = 1,
        scGas = 2,
        scEnergy = 3
    } StateConstants;

    typedef [uuid(57C52839-C34C-4F02-B8BB-2E864DA97C58), version(1.0)]
    enum {
        ccPercent = 0xffffffff,
        ccMass = 1,
        ccEnergy = 2,
        ccVolume = 3,
        ccLength = 4,
        ccArea = 5,
        ccPower = 11,
        ccShare = 24,
        ccSaturation = 20,
        ccCurrency = 12,
        ccTransport = 14,
        ccOther = 17
    } UnitClassConstants;

    typedef [uuid(7E4115AA-B8CE-4064-ADD6-310C5F697ADF), version(1.0)]
    enum {
        ucPercent = 0xffffffff,
        ucSaturation = 93,
        ucShare = 91,
        ucNoData = 95,
        ucGJ = 7,
        ucMJ = 86,
        ucTonnes = 2,
        ucKG = 1,
        ucTOE = 8,
        ucBOE = 15,
        ucKW = 42,
        ucMW = 43,
        ucGW = 52,
        ucKWHR = 10,
        ucMWHR = 14,
        ucGWHR = 11,
        ucDollar = 47,
        ucL = 20,
        ucM3 = 21,
        ucMeter = 29,
        ucMile = 28,
        ucBTU = 12,
        ucMMBTU = 101,
        ucPassKM = 61,
        ucTonneKM = 63
    } UnitConstants;

    typedef [uuid(A84FD1E2-2DC2-46CE-A4CA-BA26DB93708B), version(1.0)]
    enum {
        xcNone = 0,
        xcThousand = 3,
        xcMillion = 6,
        xcPercent = 0xfffffffe,
        xcBillion = 9,
        xcTrillion = 12,
        xcLakh = 5,
        xcCrore = 7,
        xcHundred = 2
    } ScaleConstants;

    typedef [uuid(8253515D-84D2-4AB4-A432-9B012AEF62AB), version(1.0)]
    enum {
        mcMinYear = 1900,
        mcMaxYear = 2500
    } MiscConstants;

    typedef [uuid(A212C76C-5E67-4609-9840-A9C409706824), version(1.0)]
    enum {
        acSilent = 0,
        acQuestions = 2,
        acErrors = 1,
        acWarnings = 3,
        acMessages = 4
    } AutomationConstants;

    typedef [uuid(B171FF67-F5AD-4A8D-84FD-E8534FD2C95E), version(1.0)]
    enum {
        vcAllDemand = 1,
        vcDemandCategories = 101,
        vcDemandTechnologies = 104,
        vcAllTransformation = 2,
        vcTransformationModules = 102,
        vcTransformationProcesses = 103,
        vcTransformationOutputs = 107,
        vcResources = 15,
        vcEnvironment = 34,
        vcStockChanges = 25,
        vcStatDiffs = 24,
        vcIndicators = 38,
        vcNonEnergyEffects = 27,
        vcAll = 0xfffffffe,
        vcDemandAggregateIntensity = 108
    } UserVariableBranchTypeConstants;

    typedef [uuid(DE909BB2-0683-4141-85C1-E54D7E4C6B25)]
    enum {
        dcCOPD = 0,
        dcALRI = 1,
        dcStroke = 2,
        dcLungCancer = 3,
        dcIHD = 5,
        dcAllDiseases = 0xffffffff
    } DiseaseConstants;

    typedef [uuid(21A7A6E2-01EA-4F9C-B442-A7BA5E28D53B)]
    enum {
        dsMean = 0xffffffff,
        dsVariance = 0xfffffffd,
        dsStandardDeviation = 0xfffffffe,
        dsMinimum = 0xfffffffa,
        dsMaximum = 0xfffffffb,
        dsObservations = 0xfffffff9,
        dsGeometricMean = 0xfffffff8,
        dsHarmonicMean = 0xfffffff7
    } DiseaseStats;
};
